<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Spring | You Sharp]]></title>
  <link href="http://nkcoder.github.io/blog/categories/spring/atom.xml" rel="self"/>
  <link href="http://nkcoder.github.io/"/>
  <updated>2014-03-20T08:45:17+08:00</updated>
  <id>http://nkcoder.github.io/</id>
  <author>
    <name><![CDATA[lingguo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Spring持久化之JDBC]]></title>
    <link href="http://nkcoder.github.io/blog/20140316/spring-jdbc/"/>
    <updated>2014-03-16T18:01:26+08:00</updated>
    <id>http://nkcoder.github.io/blog/20140316/spring-jdbc</id>
    <content type="html"><![CDATA[<p>这个小系列介绍Spring的持久化策略，主要关注当前应用最广泛的三种方式：Spring JDBC， MyBatis以及Hibernate。
使用JDBC的优劣如下：</p>

<ul>
<li>优势：相对于持久化框架，使用JDBC，不需要掌握其它框架的查询语言，允许我们在更低的层次上处理数据，能够访问数据库中单独的列，而且能够更好地对数据访问的性能进行调优。</li>
<li>劣势：随着项目的规模和复杂度的提升，使用JDBC会非常繁琐，同时不易于处理复杂的问题。</li>
<li>Spring JDBC：提供数据访问模板，简化JDBC编程，同时提供了平台无关的持久化异常体系。</li>
</ul>


<h3>1. 配置数据源</h3>

<p>在生产环境，考虑到性能，应该使用数据库连接池。以commons dbcp配置为例，配置如下：</p>

<pre><code>&lt;context:property-placeholder location="classpath:jdbc.properties"/&gt;

&lt;bean id="vrsDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="${jdbc.drvier}"/&gt;
    &lt;property name="url" value="${jdbc.videodb.url}"/&gt;
    &lt;property name="username" value="${jdbc.videodb.username}"/&gt;
    &lt;property name="password" value="${jdbc.videodb.password}"/&gt;
    &lt;property name="maxActive" value="${jdbc.videodb.maxActive}"/&gt;
    &lt;property name="initialSize" value="${jdbc.videodb.initialSize}"/&gt;
&lt;/bean&gt;
</code></pre>

<blockquote><p>主要属性参数说明：</p></blockquote>

<ul>
<li>driverClassName: JDBC驱动的全限定类名，如mysql就是：com.mysql.jdbc.Driver；</li>
<li>url：JDBC的url，如使用mysql的url：jdbc:mysql://10.11.132.193:3306/vrs；</li>
<li>username, password: 连接该数据源的用户名和密码；</li>
<li>initialSize：表示初始大小，即连接池启动时创建的连接数量；</li>
<li>maxActive：表示同一时间可从池中分配的最大连接数，0表示无限制；</li>
<li>maxIdle：池里不会被释放的最大连接数，0表示无限制；</li>
<li>minIdle：在不创建新连接的情况下，池中保持空闲的最小连接数；</li>
<li>maxWait：没有可用连接时，在抛出异常之前，池等待连接回收的最大时间；-1表示无线等待；</li>
<li>validationQuery：验证连接的sql查询，至少返回一行；
更多属性参考<a href="http://commons.apache.org/proper/commons-dbcp/configuration.html">wiki页</a></li>
</ul>


<blockquote><p>其它推荐的连接池有：</p></blockquote>

<ul>
<li><a href="http://www.mchange.com/projects/c3p0/">c3p0</a>: 适合多线程环境；</li>
<li><a href="https://github.com/alibaba/druid">druid</a>：完善的监控功能；</li>
</ul>


<h3>2. 使用JdbcTemplate</h3>

<p>使用JdbcTemplate类，在sql语句中，以?作为参数的占位符，传入的参数的顺序与sql语句中?的顺序必须是一一对应的。</p>

<p>首先在xml配置文件里添加jdbcTemplate的bean，其参数<code>dataSource</code>引用之前定义的数据源：</p>

<pre><code>&lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt;
    &lt;property name="dataSource" ref="vrsDataSource"/&gt;
&lt;/bean&gt;
</code></pre>

<p>然后，在dao类中引用JdbcTemplate类，并注入：</p>

<pre><code>@Resource(name = "jdbcTemplate")
JdbcTemplate jdbcTemplate;
</code></pre>

<p>查询
返回基本类型：</p>

<pre><code>String getUserById = "select name from students where id = ?";
String userName = jdbcTemplate.queryForObject(getUserById, new Object[]{3}, String.class);
</code></pre>

<p>返回<code>Map&lt;String, Object&gt;</code>，key为列名，value为对应列的值，此时返回值只能有一行，否则报错：</p>

<pre><code>String getStudentByNumber = "select * from students where number = ?";
Map&lt;String, Object&gt; studentMap = jdbcTemplate.queryForMap(getStudentByNumber, 111);
</code></pre>

<p>返回<code>List&lt;Map&lt;String, Object&gt;&gt;</code>, 可以返回多列：</p>

<pre><code>String getStudentsByCity = "select * from students where city = ?";
List&lt;Map&lt;String, Object&gt;&gt; studentList = jdbcTemplate.queryForList(getStudentsByCity, "tianjin");
</code></pre>

<p>返回自定义class的对象，需要实现RowMapper接口，定义列名和属性的映射：
首先实现RowMapper接口：</p>

<pre><code>public class StudentRowMapper implements RowMapper&lt;Students&gt; {
    @Override
    public Students mapRow(ResultSet rs, int rowNum) throws SQLException {
        Students students = new Students();
        students.setId(rs.getInt("id"));
        students.setName(rs.getString("name"));
        students.setSex(rs.getString("sex"));
        students.setNumber(rs.getInt("number"));
        students.setEnable(rs.getInt("enable"));
        students.setCity(rs.getString("city"));
        return students;
    }
}
</code></pre>

<p>然后，使用query或者queryForObject查询多行或一行：</p>

<pre><code>String getStudentsByCity = "select * from students where city = ?";
List&lt;Students&gt; studentsList = jdbcTemplate.query(getStudentsByCity, new StudentRowMapper(), "tianjin");
</code></pre>

<h3>2. 使用NamedParameterJdbcTemplate</h3>

<p>使用NamedParameterJdbcTemplate类，sql语句中的参数是以命名的变量来表示，传入参数时，只要参数名一致即可，索引位置不必一一对应。
首先在xml配置文件里定义NamedParameterJdbcTemplate的bean：</p>

<pre><code>&lt;bean id="namedParameterJdbcTemplate" class="org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate"&gt;
    &lt;constructor-arg name="dataSource" ref="feedbackDataSource"/&gt;
&lt;/bean&gt;
</code></pre>

<p>然后将namedParameterJdbcTemplate bean注入到dao中，</p>

<pre><code>@Resource(name = "namedParameterJdbcTemplate")
NamedParameterJdbcTemplate namedParameterJdbcTemplate;
</code></pre>

<p>定义sql，参数以(:变量名)形式给出即可，如：</p>

<pre><code>String getStudentByNumber = "select * from students where number = (:number) and city = (:city)";
NamedParameterJdbcTemplate namedParameterJdbcTemplate = (NamedParameterJdbcTemplate) context.getBean("namedParameterJdbcTemplate");
Map&lt;String, Object&gt; queryMap = new HashMap&lt;String, Object&gt;();
queryMap.put("number", 333);
queryMap.put("city", "tianjin");
List&lt;Map&lt;String, Object&gt;&gt; mapList = namedParameterJdbcTemplate.queryForList(getStudentByNumber, queryMap);
</code></pre>

<blockquote><p>除了使用命名参数外，NamedParameterJdbcTemplate与JdbcTempate的主要用法都是一致的。</p></blockquote>

<h3>3. 使用JdbcDaoSupport</h3>

<p>JdbcDaoSupport是一个父类，如果有多个dao类，通过继承JdbcDaoSupport，可以更方便地获取jdbcTemplate。
首先让dao类继承JdbcDaoSupport类：</p>

<pre><code>public class InfoJdbcImpl extends JdbcDaoSupport implements VideoInfoDao {
</code></pre>

<p>然后在定义dao类的bean时，注入一个<code>jdbcTemplate</code>属性，或者直接注入一个<code>dataSource</code>属性（这两个属性来自于JdbcDaoSupport）：</p>

<pre><code>&lt;bean id="infoJdbcImpl" class="com.sohu.tv.dao.impl.InfoJdbcImpl"&gt;
    &lt;property name="dataSource" ref="feedbackDataSource"/&gt;
&lt;/bean&gt;
</code></pre>

<p>然后通过getJdbcTemplate()获取jdbcTemplate，实现dao层的逻辑：</p>

<pre><code>String getStudentByNumber = "select * from students where number = ?";
Map&lt;String, Object&gt; studentMap = getJdbcTemplate().queryForMap(getStudentByNumber, 111);
</code></pre>

<blockquote><p><code>NamedParameterJdbcDaoSupport</code>与<code>JdbcDaoSupport</code>的用法类似。</p></blockquote>

<h4>参考资料</h4>

<ul>
<li><a href="http://www.amazon.cn/Spring%E5%AE%9E%E6%88%98-%E6%B2%83%E5%B0%94%E6%96%AF/dp/B00CY6UD2I/ref=sr_1_1?ie=UTF8&amp;qid=1394943496&amp;sr=8-1&amp;keywords=spring+in+action">Spring实战(第3版)</a></li>
<li><a href="http://docs.spring.io/spring/docs/3.2.8.RELEASE/javadoc-api/">spring-javadoc-api</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring AOP之入门实例]]></title>
    <link href="http://nkcoder.github.io/blog/20140313/spring-aop-example/"/>
    <updated>2014-03-13T22:58:06+08:00</updated>
    <id>http://nkcoder.github.io/blog/20140313/spring-aop-example</id>
    <content type="html"><![CDATA[<p>依赖注入（DI）有助于应用对象之间的解耦，而面向切面编程（AOP）有助于横切关注点与所影响的对象之间的解耦。所谓横切关注点，即影响应用多处的功能，这些功能各个应用模块都需要，但又不是其主要关注点，常见的横切关注点有日志、事务和安全等。</p>

<p>将横切关注点抽离形成独立的类，即形成了切面。切面主要由切点和通知构成，通知定义了切面是什么，以及何时执行何种操作；切点定义了在何处执行通知定义的操作。</p>

<p>下面以简单的日志作为切面，分别介绍通过xml配置和注解实现AOP。</p>

<h3>0. 添加依赖</h3>

<p>因为Spring AOP用到AspectJ的相关对象和注解，需要添加AspectJ的依赖：</p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;
    &lt;version&gt;1.7.4&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
    &lt;version&gt;1.7.4&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;
    &lt;version&gt;${spring.version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<h3>1. 通过XML配置实现</h3>

<p>1.1 将日志类作为切面，定义为bean即可：</p>

<pre><code>@Service("logService")
public class LogService {
    private Logger logger = LoggerFactory.getLogger(LogService.class);

    public void printLog(ProceedingJoinPoint joinPoint) throws Throwable{
        logger.info("before service is called...");

        String methodModifier = joinPoint.getSignature().getDeclaringTypeName();
        String methodName = joinPoint.getSignature().getName();
        Object[] argsArr = joinPoint.getArgs();
        logger.info("class: {}; method: {}; args: {}", methodModifier, methodName, Arrays.toString(argsArr));
        joinPoint.proceed();

        logger.info("after service is called....");
    }
}
</code></pre>

<blockquote><p>首先，通过@Service注解将类定义为bean；方法printLog的参数<code>ProceedingJoinPoint</code>对象属于<code>AspectJ</code>，通过这个对象可以获取被通知的对象和方法的信息，并通过<code>proceed</code>方法执行被通知的对象。</p></blockquote>

<p>1.2 在xml配置文件里定义切面和切点</p>

<pre><code>&lt;aop:config&gt;
    &lt;aop:aspect ref="logService"&gt;
        &lt;aop:pointcut id="serviceLog" expression="execution(* org.yousharp.service.VideoService..*(..))"/&gt;
        &lt;aop:around method="printLog" pointcut-ref="serviceLog"/&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre>

<blockquote><p><code>aop:aspect</code>通过ref引用<code>logService</code> bean，将<code>LogService</code>定义为切面。<code>aop:pointcut</code>定义一个切点，被通知的对象通过<code>execution</code>表达式指定，即当<code>VideoService</code>下的任意方法被执行时，触发切面。<code>aop:aroud</code>定义一个环绕通知，引用切点*serviceLog<code>，当切面被触发时，调用</code>method`指定的方法。</p></blockquote>

<h3>2. 通过注解实现</h3>

<p>通过注解，可以直接在类上定义切面、通知和切点，无需任何xml配置。</p>

<pre><code>@Service("logService")
@Aspect
public class LogService {
    private Logger logger = LoggerFactory.getLogger(LogService.class);

    @Pointcut(value = "execution(* org.yousharp.service.VideoService.saveVideoInfo(..))")
    public void saveVideo() { }

    @Around(value = "saveVideo()")
    public void printLog(ProceedingJoinPoint joinPoint) throws Throwable{
        logger.info("before service is called...");
        String methodModifier = joinPoint.getSignature().getDeclaringTypeName();
        String methodName = joinPoint.getSignature().getName();
        Object[] argsArr = joinPoint.getArgs();
        logger.info("class: {}; method: {}; args: {}", methodModifier, methodName, Arrays.toString(argsArr));
        joinPoint.proceed();

        logger.info("after service is called....");
    }
}
</code></pre>

<blockquote><p><code>@Aspect</code>注解表示将该类定义为切面，<code>@Pointcut</code>定义切点，execution表达式与xml配置一样；切点的id即为空方法的方法名（这里的方法内容不重要，主要是供切点依附），这里即为saveVideo；<code>@Around</code>表示定义环绕通知，需要引用切点。</p></blockquote>

<h4>参考资料</h4>

<ul>
<li><a href="http://www.amazon.cn/Spring%E5%AE%9E%E6%88%98-%E6%B2%83%E5%B0%94%E6%96%AF/dp/B00CY6UD2I/ref=sr_1_1?ie=UTF8&amp;qid=1394943496&amp;sr=8-1&amp;keywords=spring+in+action">Spring实战(第3版)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring依赖注入之Java注解]]></title>
    <link href="http://nkcoder.github.io/blog/20140310/spring-di-java/"/>
    <updated>2014-03-10T23:29:44+08:00</updated>
    <id>http://nkcoder.github.io/blog/20140310/spring-di-java</id>
    <content type="html"><![CDATA[<blockquote><p>基于Java的注解，是在类级别上定义beans，在方法级别上定义bean。和自动注解一样，可以减少xml的配置。</p></blockquote>

<h3>1. xml配置</h3>

<p>在xml配置文件中添加自动扫描的配置：</p>

<pre><code>&lt;context:component-scan base-package="org.yousharp"/&gt;
</code></pre>

<blockquote><p>该配置不仅扫描构造型注解(@Controller, @Service, @Repository, @Component)，也会扫描@Configuration注解。</p></blockquote>

<h3>2. 定义dao类和service类</h3>

<p>dao类是service类的一个属性，是需要注入的对象。</p>

<pre><code>public class VideoService {
    SaveVideoInfoDao saveVideoInfoDao;

    public VideoService(){}

    public VideoService(SaveVideoInfoDao saveVideoInfoDao) {
        this.saveVideoInfoDao = saveVideoInfoDao;
    }

    public void saveVideoInfo(String info) {
        saveVideoInfoDao.printMesg(info);
    }
}

public class SaveVideoInfoDao {

    public void printMesg(String message) {
        System.out.println("saving video info....");
    }
}
</code></pre>

<blockquote><p>dao类和service类就是两个很普通的java类，没有任何注解依附。</p></blockquote>

<h3>3. 定义一个配置类</h3>

<p>单独定义一个配置类（在自动扫描包下），在类上使用@Configuration注解，在方法上使用@Bean注解：</p>

<pre><code>@Configuration
public class AppConfig {

    @Bean
    public SaveVideoInfoDao saveVideoInfoDao() {
        return new SaveVideoInfoDao();
    }

    @Bean
    public VideoService videoService() {
        VideoService videoService = new VideoService(saveVideoInfoDao());
        return videoService;
    }
}
</code></pre>

<blockquote><p>@Configuration注解等价于xml配置中的<code>beans</code>，该注解告诉Spring该类中包含一个或多个bean的定义；@Bean注解等价于xml配置中的<code>bean</code>，将方法返回的对象定义为bean，方法名为bean的id；上面第一个bean的定义等价于xml配置：</p></blockquote>

<pre><code>&lt;bean id="saveInfoDao" class="org.yousharp.AppConfig"/&gt;
</code></pre>

<p>第二个bean的定义通过构造函数实现依赖注入，其含义等价于xml配置：</p>

<pre><code>&lt;bean id="videoService" class="org.yousharp.AppConfig"&gt;
    &lt;constructor-arg name="videoService" ref="saveVideoInfoDao"&gt;
&lt;/bean&gt;
</code></pre>

<p>这里是通过构造函数实现注入，当然也可以通过setter方法实现注入。在VideoInfoService中去掉带参数的构造函数，同时对属性saveVideoInfoDao添加setter方法，修改AppConfig类中的第二个bean为：</p>

<pre><code>@Bean
public VideoService videoService() {
    VideoService videoService = new VideoService();
    videoService.setSaveVideoInfoDao(saveVideoInfoDao());
    return videoService;
}
</code></pre>

<h3>4. Controller中引用</h3>

<p>Controller里和使用xml配置bean和自动注解一样，通过bean的id获取对bean的引用。这里VideoService的bean的id为videoService。</p>

<pre><code>ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");

public void execute() {
    VideoService videoService = (VideoService) context.getBean("videoService");
    String videoInfo = "vrs video info";
    videoService.saveVideoInfo(videoInfo);
}
</code></pre>

<h4>参考资料</h4>

<ul>
<li><a href="http://www.amazon.cn/Spring%E5%AE%9E%E6%88%98-%E6%B2%83%E5%B0%94%E6%96%AF/dp/B00CY6UD2I/ref=sr_1_1?ie=UTF8&amp;qid=1394943496&amp;sr=8-1&amp;keywords=spring+in+action">Spring实战(第3版)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring依赖注入之注解注入]]></title>
    <link href="http://nkcoder.github.io/blog/20140309/spring-di-annotation/"/>
    <updated>2014-03-09T18:19:11+08:00</updated>
    <id>http://nkcoder.github.io/blog/20140309/spring-di-annotation</id>
    <content type="html"><![CDATA[<h3>1. bean的自动装配和自动检测的区别</h3>

<p>启用注解装配，在xml配置文件里添加：</p>

<pre><code>&lt;context:annotation-config/&gt;
</code></pre>

<p>启用自动扫描注解，在xml配置文件里添加：</p>

<pre><code>&lt;context:component-scan base-package="org.yousharp.base"/&gt;
</code></pre>

<blockquote><p>二者的区别：
自动装配表示通过@Autowired, @Inject, @Resource等实现对属性或构造函数的自动注入；仍然需要在配置文件里定义bean，只是通过自动装配省去了<code>property</code>和<code>constructor-arg</code>的配置。
自动检测是扫描特定的注解（包括：@Component, @Controller, @Service, @Repository)，将注解过的类自动定义为bean，自动检测是自动装配的超集，通过自动检测，可以省去在xml配置文件里定义<code>bean</code>了。</p></blockquote>

<h3>2. 通过自动装配和注解实现注入</h3>

<p>在xml配置文件里启动注解装配：</p>

<pre><code>&lt;context:annotation-config/&gt;
</code></pre>

<p>定义bean：</p>

<pre><code>&lt;bean id="saveVideoInfoDao" class="org.dao.SaveVideoInfoDao"/&gt;
</code></pre>

<p>然后在需要注入的属性上或者其setter方法上，或者构造函数上，添加@Autowired, @Inject, @Resource等注解实现自动注入：</p>

<pre><code>//@Autowired
//@Inject
@Resource
public void setSaveVideoInfoDao(SaveVideoInfoDao videoInfoDao) {
    this.saveVideoInfoDao = videoInfoDao;
}
</code></pre>

<blockquote><p>@Autowired, @Inject, @Resource的区别：@Autowired是Spring 3.0的注解，是通过byType形式实现注解，可以通过@Qualifier根据bean的id进行限定；使用@Autowired注解即引入了对Spring的依赖。@Inject是JSR 330的注解，使用该注解需要导入包javax.inject，@Named(value=&ldquo;&rdquo;)可以根据bean的id进行限定；@Resource是JSR 250的注解，可以通过value限定bean的id，如@Resource(value=&ldquo;&rdquo;);</p></blockquote>

<h3>3. 使用自动检测注解实现注入</h3>

<p>在xml配置文件里增加自动检测的配置：</p>

<pre><code>&lt;context:component-scan base-package="org.yousharp.base"/&gt;
</code></pre>

<p>将需要被自动检测而注册为bean的类使用对应的构造型注解：</p>

<pre><code>@Repository
public class SaveVideoInfoDao {

    public void printMesg(String message) {
        System.out.println("saving video info....");
    }
}
</code></pre>

<p>使用注解对依赖的属性进行输入：</p>

<pre><code>@Service
public class VideoService {
    @Resource
    SaveVideoInfoDao saveVideoInfoDao;

    public void saveVideoInfo(String info) {
        saveVideoInfoDao.printMesg(info);
    }
}
</code></pre>

<blockquote><p>@Component是通用的注解，@Controller表示将该类定义为Spring MVC的控制器，@Service定义服务层，@Repository定义数据仓库；这些构造型注解默认以无限定类名作为bean的id，也可以显式指定id名称，如@Service(&ldquo;videoInfoService&rdquo;)或者@Service(name=&ldquo;videoInfoService&rdquo;);</p></blockquote>

<h3>4. 自动检测注解的过滤</h3>

<p>可以为扫描行为定义过滤器，如<code>context:include-filter</code>, <code>context:exclude-filter</code></p>

<pre><code>&lt;context:component-scan base-package="org.yousharp"&gt;
    &lt;context:include-filter type="assignable" expression="org.yousharp.dao.SaveVideoInfoDao"/&gt;
    &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Component"/&gt;
&lt;/context:component-scan&gt;
</code></pre>

<blockquote><p><code>context:include-filter</code>表示需要扫描并注解的类，<code>context:exclude-filter</code>表示扫描时需要排除的包；<code>type</code>一种有5中，<code>assignable</code>表示继承自<code>expression</code>所指定的包，<code>annotation</code>表示所有expression所指定的注解。</p></blockquote>

<h4>参考资料</h4>

<ul>
<li><a href="http://www.amazon.cn/Spring%E5%AE%9E%E6%88%98-%E6%B2%83%E5%B0%94%E6%96%AF/dp/B00CY6UD2I/ref=sr_1_1?ie=UTF8&amp;qid=1394943496&amp;sr=8-1&amp;keywords=spring+in+action">Spring实战(第3版)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring依赖注入之XML配置]]></title>
    <link href="http://nkcoder.github.io/blog/20140308/spring-di-xml/"/>
    <updated>2014-03-08T21:36:47+08:00</updated>
    <id>http://nkcoder.github.io/blog/20140308/spring-di-xml</id>
    <content type="html"><![CDATA[<blockquote><p>因为项目中一直要用到Spring相关的知识，所以最近在看<a href="http://www.amazon.cn/Spring%E5%AE%9E%E6%88%98-%E6%B2%83%E5%B0%94%E6%96%AF/dp/B00CY6UD2I/ref=sr_1_1?ie=UTF8&amp;qid=1394286577&amp;sr=8-1&amp;keywords=spring%E5%AE%9E%E6%88%98">Spring实战</a>这本书，希望对Spring有一个整理的了解和把握。不得不说，这是一本好书，中文译本也不错。这个系列，记录自己关于Spring的笔记和理解，一是加深理解，同时也希望对别人有所帮助。</p></blockquote>

<h3>1. 通过构造方法和xml配置注入</h3>

<blockquote><p>定义带参数的构造函数，使依赖对象作为构造函数的参数：</p></blockquote>

<pre><code>public class VideoInfoServiceImpl implements VideoInfoService {
    VideoInfoDao videoInfoDao;

    public VideoInfoServiceImpl() {}

    public VideoInfoServiceImpl(VideoInfoDao videoInfoDao) {
        this.videoInfoDao = videoInfoDao;
    }

    @Override
    public List&lt;Map&lt;String, Object&gt;&gt; getVideos(Map&lt;String, Object&gt; queryMap) {
        List&lt;Map&lt;String, Object&gt;&gt; videoList = videoInfoDao.getVideos(queryMap);
        return videoList;
    }
}
</code></pre>

<blockquote><p>在定义bean时，使用<code>constructor-arg</code>标签，name表示构造函数的参数，ref表示引用另一个bean；参数也可以为基本类型，此时使用value标签，而不是ref。(如果不使用<code>constructor-arg</code>，则bean实例化时调用的是默认的不带参数的构造函数)</p></blockquote>

<pre><code>&lt;bean id="videoInfoServiceImpl" class="com.sohu.tv.service.impl.VideoInfoServiceImpl"&gt;
    &lt;constructor-arg name="videoInfoDao" ref="videoInfoDaoImpl"/&gt;
&lt;/bean&gt;

&lt;bean id="videoInfoServiceImpl" class="com.sohu.tv.service.impl.VideoInfoServiceImpl"&gt;
    &lt;constructor-arg name="id" value="25"/&gt;
&lt;/bean&gt;
</code></pre>

<h3>2. 通过setter方法和xml配置注入</h3>

<blockquote><p>定义依赖对象的setter方法，在bean定义时，使用<code>property</code>标签表示调用指定属性的setter方法，实现注入：</p></blockquote>

<pre><code>public class VideoInfoServiceImpl implements VideoInfoService {
    VideoInfoDao videoInfoDao;

    @Override
    public List&lt;Map&lt;String, Object&gt;&gt; getVideos(Map&lt;String, Object&gt; queryMap) {
        List&lt;Map&lt;String, Object&gt;&gt; videoList = videoInfoDao.getVideos(queryMap);
        return videoList;
    }

    public void setVideoInfoDao(VideoInfoDao videoInfoDao) {
        this.videoInfoDao = videoInfoDao;
    }
}
</code></pre>

<blockquote><p>property指定属性为videoInfoDao，则bean实例化后调用setVideoInfoDao方法实现注入；ref表示引用另一个bean，value表示基本类型值，int, float, true等。</p></blockquote>

<pre><code>&lt;bean id="videoInfoServiceImpl" class="com.sohu.tv.service.impl.VideoInfoServiceImpl"&gt;
    &lt;property name="videoInfoDao" ref="videoInfoDaoImpl"/&gt;
&lt;/bean&gt;
</code></pre>

<blockquote><p>此时也可以通过<code>bean</code>的p属性实现注入，比较简洁，需要加入p命令空间，和<code>property</code>方式是等价的。</p></blockquote>

<pre><code>xmlns:p="http://www.springframework.org/schema/p"

&lt;bean id="videoInfoServiceImpl" class="com.sohu.tv.service.impl.VideoInfoServiceImpl"
        p:videoInfoDao-ref="videoInfoDaoImpl" /&gt;
</code></pre>

<h3>3. 通过SpEL表达式注入</h3>

<blockquote><p>SpEL可以实现在运行时装配。SpEL通过#{}获取变量的值，{}中既可以是值类型，也可以是引用类型，通过bean的id引用其它的bean，此时，在SpEL中通过value引用其它的bean和通过ref直接引用bean的效果是相同的。</p></blockquote>

<pre><code>&lt;bean id="videoInfoServiceImpl" class="com.sohu.tv.service.impl.VideoInfoServiceImpl"&gt;
    &lt;!--&lt;property name="videoInfoDao" ref="videoInfoDaoImpl"/&gt;--&gt;
    &lt;property name="videoInfoDao" value="#{videoInfoDaoImpl}" /&gt;
&lt;/bean&gt;
</code></pre>

<h3>4. 通过setter方法和autowire=&ldquo;byName"自动装配注入</h3>

<blockquote><p>根据bean的名字进行注入，使用autowire=&ldquo;byName"，则寻找与属性名字相同的bean，通过属性的setter方法注入。</p></blockquote>

<pre><code>&lt;bean id="saveVideoInfoDao" class="org.dao.SaveVideoInfoDao"/&gt;
&lt;bean id="videoService" class="org.service.VideoService" autowire="byName"/&gt;
</code></pre>

<h3>5. 通过setter方法和autowire=&ldquo;byType"自动装配注入</h3>

<blockquote><p>根据bean的类型进行注入，使用autowire=&ldquo;byType"，则寻找与属性名字相同的bean，通过属性的setter方法注入：</p></blockquote>

<pre><code>&lt;bean id="saveVideoInfoDao" class="org.dao.SaveVideoInfoDao"/&gt;
&lt;bean id="videoService" class="org.service.VideoService" autowire="byType"/&gt;
</code></pre>

<h3>6. 通过factory-method给单例类定义bean</h3>

<blockquote><p>如果类的构造函数不可用，比如单例类，构造函数私有，通过public的接口获取实例；定义单例类的bean时，使用<code>factory-method</code>，表示调用类的静态方法构造实例：</p></blockquote>

<pre><code>&lt;bean id="singleton" class="yousharp.Singleton" factory-method="getInstance"/&gt;
&lt;bean id="factoryService" class="yousharp.FactoryService"&gt;
    &lt;constructor-arg name="singleton" ref="singleton"/&gt;
&lt;/bean&gt;
</code></pre>

<h3>7. 定义bean的作用域</h3>

<blockquote><p>默认是singleton，可以设置scope属性为prototype，表示每次调用都创建一个新实例：</p></blockquote>

<pre><code>&lt;bean id="videoInfoServiceImpl" class="com.sohu.tv.service.impl.VideoInfoServiceImpl"
    scope="prototype"/&gt;
</code></pre>

<h3>8. 装配list</h3>

<blockquote><p>数组或Collection的任意实现如List, ArrayList等都可以使用list和set来装配，区别在于set中不允许有重复元素。定义list成员的setter方法：</p></blockquote>

<pre><code>private List&lt;VideoInfoDao&gt; videoInfoDaoList;

public void setVideoInfoDaoList(List&lt;VideoInfoDao&gt; videoInfoDaoList) {
    this.videoInfoDaoList = videoInfoDaoList;
}
</code></pre>

<blockquote><p>在xml配置文件里，在<code>property</code>里定义<code>list</code>，给list成员注入实例：</p></blockquote>

<pre><code>&lt;bean id="videoInfoServiceImpl" class="com.sohu.tv.service.impl.VideoInfoServiceImpl"&gt;
    &lt;property name="videoInfoDaoList"&gt;
        &lt;list&gt;
            &lt;ref bean="jdbcDaoImple"/&gt;
            &lt;ref bean="mybatisDaoImpl"/&gt;
            &lt;ref bean="hibernateDaoImpl"/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>

<h3>9. 装配map</h3>

<blockquote><p>如果需要对一个map成员变量进行注入，在<code>property</code>里，通过<code>map</code>来实现注入，其中key和value都可以是值类型或引用类型；</p></blockquote>

<pre><code>private Map&lt;String, VideoInfoDaoImpl&gt; videoInfoDaoMap ;

public void setVideoInfoDaoList(Map&lt;String, VideoInfoDaoImpl&gt; videoInfoDaoMap) {
    this.videoInfoDaoMap = videoInfoDaoMap;
}

&lt;bean id="videoInfoServiceImpl" class="com.sohu.tv.service.impl.VideoInfoServiceImpl"&gt;
    &lt;property name="videoInfoDaoList"&gt;
        &lt;map&gt;
            &lt;entry key="jdbc" value-ref="videoInfoDaoImpl"/&gt;
            &lt;entry key="mybatis" value-ref="videoInfoDaoImpl"/&gt;
            &lt;entry key="hibernate" value-ref="videoInfoDaoImpl"/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>

<h3>10. 装配property</h3>

<blockquote><p>property也是key-value对，与map的区别是，其key和value必须都是String类型。</p></blockquote>

<pre><code>Properties props;
public void setProps(Properties props) {
    this.props = props;
}

&lt;bean id="videoInfoServiceImpl" class="com.sohu.tv.service.impl.VideoInfoServiceImpl" &gt;
    &lt;property name="props"&gt;
        &lt;props&gt;
            &lt;prop key="daily"&gt;30 00 * * *&lt;/prop&gt;
            &lt;prop key="weekly"&gt;30 00 * * 1&lt;/prop&gt;
            &lt;prop key="monthly"&gt;30 00 * 1 *&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>

<h4>参考资料</h4>

<ul>
<li><a href="http://www.amazon.cn/Spring%E5%AE%9E%E6%88%98-%E6%B2%83%E5%B0%94%E6%96%AF/dp/B00CY6UD2I/ref=sr_1_1?ie=UTF8&amp;qid=1394943496&amp;sr=8-1&amp;keywords=spring+in+action">Spring实战(第3版)</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
