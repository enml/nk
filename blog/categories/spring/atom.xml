<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Spring | You Sharp]]></title>
  <link href="http://nkcoder.github.io/blog/categories/spring/atom.xml" rel="self"/>
  <link href="http://nkcoder.github.io/"/>
  <updated>2014-03-09T18:20:41+08:00</updated>
  <id>http://nkcoder.github.io/</id>
  <author>
    <name><![CDATA[lingguo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Spring依赖注入之注解注入]]></title>
    <link href="http://nkcoder.github.io/blog/20140309/spring-di-annotation/"/>
    <updated>2014-03-09T18:19:11+08:00</updated>
    <id>http://nkcoder.github.io/blog/20140309/spring-di-annotation</id>
    <content type="html"><![CDATA[<h3>1. bean的自动装配和自动检测的区别</h3>

<p>启用注解装配，在xml配置文件里添加：</p>

<pre><code>&lt;context:annotation-config/&gt;
</code></pre>

<p>启用自动扫描注解，在xml配置文件里添加：</p>

<pre><code>&lt;context:component-scan base-package="org.yousharp.base"/&gt;
</code></pre>

<blockquote><p>二者的区别：
自动装配表示通过@Autowired, @Inject, @Resource等实现对属性或构造函数的自动注入；仍然需要在配置文件里定义bean，只是通过自动装配省去了<code>property</code>和<code>constructor-arg</code>的配置。
自动检测是扫描特定的注解（包括：@Component, @Controller, @Service, @Repository)，将注解过的类自动定义为bean，自动检测是自动装配的超集，通过自动检测，可以省去在xml配置文件里定义<code>bean</code>了。</p></blockquote>

<h3>2. 通过自动装配和注解实现注入</h3>

<p>在xml配置文件里启动注解装配：</p>

<pre><code>&lt;context:annotation-config/&gt;
</code></pre>

<p>定义bean：</p>

<pre><code>&lt;bean id="saveVideoInfoDao" class="org.dao.SaveVideoInfoDao"/&gt;
</code></pre>

<p>然后在需要注入的属性上或者其setter方法上，或者构造函数上，添加@Autowired, @Inject, @Resource等注解实现自动注入：</p>

<pre><code>//@Autowired
//@Inject
@Resource
public void setSaveVideoInfoDao(SaveVideoInfoDao videoInfoDao) {
    this.saveVideoInfoDao = videoInfoDao;
}
</code></pre>

<blockquote><p>@Autowired, @Inject, @Resource的区别：@Autowired是Spring 3.0的注解，是通过byType形式实现注解，可以通过@Qualifier根据bean的id进行限定；使用@Autowired注解即引入了对Spring的依赖。@Inject是JSR 330的注解，使用该注解需要导入包javax.inject，@Named(value=&ldquo;&rdquo;)可以根据bean的id进行限定；@Resource是JSR 250的注解，可以通过value限定bean的id，如@Resource(value=&ldquo;&rdquo;);</p></blockquote>

<h3>3. 使用自动检测注解实现注入</h3>

<p>在xml配置文件里增加自动检测的配置：</p>

<pre><code>&lt;context:component-scan base-package="org.yousharp.base"/&gt;
</code></pre>

<p>将需要被自动检测而注册为bean的类使用对应的构造型注解：</p>

<pre><code>@Repository
public class SaveVideoInfoDao {

    public void printMesg(String message) {
        System.out.println("saving video info....");
    }
}
</code></pre>

<p>使用注解对依赖的属性进行输入：</p>

<pre><code>@Service
public class VideoService {
    @Resource
    SaveVideoInfoDao saveVideoInfoDao;

    public void saveVideoInfo(String info) {
        saveVideoInfoDao.printMesg(info);
    }
}
</code></pre>

<blockquote><p>@Component是通用的注解，@Controller表示将该类定义为Spring MVC的控制器，@Service定义服务层，@Repository定义数据仓库；这些构造型注解默认以无限定类名作为bean的id，也可以显式指定id名称，如@Service(&ldquo;videoInfoService&rdquo;)或者@Service(name=&ldquo;videoInfoService&rdquo;);</p></blockquote>

<h3>4. 自动检测注解的过滤</h3>

<p>可以为扫描行为定义过滤器，如<code>context:include-filter</code>, <code>context:exclude-filter</code></p>

<pre><code>&lt;context:component-scan base-package="org.yousharp"&gt;
    &lt;context:include-filter type="assignable" expression="org.yousharp.dao.SaveVideoInfoDao"/&gt;
    &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Component"/&gt;
&lt;/context:component-scan&gt;
</code></pre>

<blockquote><p><code>context:include-filter</code>表示需要扫描并注解的类，<code>context:exclude-filter</code>表示扫描时需要排除的包；<code>type</code>一种有5中，<code>assignable</code>表示继承自<code>expression</code>所指定的包，<code>annotation</code>表示所有expression所指定的注解。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring依赖注入之XML配置]]></title>
    <link href="http://nkcoder.github.io/blog/20140308/spring-di-xml/"/>
    <updated>2014-03-08T21:36:47+08:00</updated>
    <id>http://nkcoder.github.io/blog/20140308/spring-di-xml</id>
    <content type="html"><![CDATA[<blockquote><p>因为项目中一直要用到Spring相关的知识，所以最近在看<a href="http://www.amazon.cn/Spring%E5%AE%9E%E6%88%98-%E6%B2%83%E5%B0%94%E6%96%AF/dp/B00CY6UD2I/ref=sr_1_1?ie=UTF8&amp;qid=1394286577&amp;sr=8-1&amp;keywords=spring%E5%AE%9E%E6%88%98">Spring实战</a>这本书，希望对Spring有一个整理的了解和把握。不得不说，这是一本好书，中文译本也不错。这个系列，记录自己关于Spring的笔记和理解，一是加深理解，同时也希望对别人有所帮助。</p></blockquote>

<h3>1. 通过构造方法和xml配置注入</h3>

<blockquote><p>定义带参数的构造函数，使依赖对象作为构造函数的参数：</p></blockquote>

<pre><code>public class VideoInfoServiceImpl implements VideoInfoService {
    VideoInfoDao videoInfoDao;

    public VideoInfoServiceImpl() {}

    public VideoInfoServiceImpl(VideoInfoDao videoInfoDao) {
        this.videoInfoDao = videoInfoDao;
    }

    @Override
    public List&lt;Map&lt;String, Object&gt;&gt; getVideos(Map&lt;String, Object&gt; queryMap) {
        List&lt;Map&lt;String, Object&gt;&gt; videoList = videoInfoDao.getVideos(queryMap);
        return videoList;
    }
}
</code></pre>

<blockquote><p>在定义bean时，使用<code>constructor-arg</code>标签，name表示构造函数的参数，ref表示引用另一个bean；参数也可以为基本类型，此时使用value标签，而不是ref。(如果不使用<code>constructor-arg</code>，则bean实例化时调用的是默认的不带参数的构造函数)</p></blockquote>

<pre><code>&lt;bean id="videoInfoServiceImpl" class="com.sohu.tv.service.impl.VideoInfoServiceImpl"&gt;
    &lt;constructor-arg name="videoInfoDao" ref="videoInfoDaoImpl"/&gt;
&lt;/bean&gt;

&lt;bean id="videoInfoServiceImpl" class="com.sohu.tv.service.impl.VideoInfoServiceImpl"&gt;
    &lt;constructor-arg name="id" value="25"/&gt;
&lt;/bean&gt;
</code></pre>

<h3>2. 通过setter方法和xml配置注入</h3>

<blockquote><p>定义依赖对象的setter方法，在bean定义时，使用<code>property</code>标签表示调用指定属性的setter方法，实现注入：</p></blockquote>

<pre><code>public class VideoInfoServiceImpl implements VideoInfoService {
    VideoInfoDao videoInfoDao;

    @Override
    public List&lt;Map&lt;String, Object&gt;&gt; getVideos(Map&lt;String, Object&gt; queryMap) {
        List&lt;Map&lt;String, Object&gt;&gt; videoList = videoInfoDao.getVideos(queryMap);
        return videoList;
    }

    public void setVideoInfoDao(VideoInfoDao videoInfoDao) {
        this.videoInfoDao = videoInfoDao;
    }
}
</code></pre>

<blockquote><p>property指定属性为videoInfoDao，则bean实例化后调用setVideoInfoDao方法实现注入；ref表示引用另一个bean，value表示基本类型值，int, float, true等。</p></blockquote>

<pre><code>&lt;bean id="videoInfoServiceImpl" class="com.sohu.tv.service.impl.VideoInfoServiceImpl"&gt;
    &lt;property name="videoInfoDao" ref="videoInfoDaoImpl"/&gt;
&lt;/bean&gt;
</code></pre>

<blockquote><p>此时也可以通过<code>bean</code>的p属性实现注入，比较简洁，需要加入p命令空间，和<code>property</code>方式是等价的。</p></blockquote>

<pre><code>xmlns:p="http://www.springframework.org/schema/p"

&lt;bean id="videoInfoServiceImpl" class="com.sohu.tv.service.impl.VideoInfoServiceImpl"
        p:videoInfoDao-ref="videoInfoDaoImpl" /&gt;
</code></pre>

<h3>3. 通过SpEL表达式注入</h3>

<blockquote><p>SpEL可以实现在运行时装配。SpEL通过#{}获取变量的值，{}中既可以是值类型，也可以是引用类型，通过bean的id引用其它的bean，此时，在SpEL中通过value引用其它的bean和通过ref直接引用bean的效果是相同的。</p></blockquote>

<pre><code>&lt;bean id="videoInfoServiceImpl" class="com.sohu.tv.service.impl.VideoInfoServiceImpl"&gt;
    &lt;!--&lt;property name="videoInfoDao" ref="videoInfoDaoImpl"/&gt;--&gt;
    &lt;property name="videoInfoDao" value="#{videoInfoDaoImpl}" /&gt;
&lt;/bean&gt;
</code></pre>

<h3>4. 通过setter方法和autowire=&ldquo;byName"自动装配注入</h3>

<blockquote><p>根据bean的名字进行注入，使用autowire=&ldquo;byName"，则寻找与属性名字相同的bean，通过属性的setter方法注入。</p></blockquote>

<pre><code>&lt;bean id="saveVideoInfoDao" class="org.dao.SaveVideoInfoDao"/&gt;
&lt;bean id="videoService" class="org.service.VideoService" autowire="byName"/&gt;
</code></pre>

<h3>5. 通过setter方法和autowire=&ldquo;byType"自动装配注入</h3>

<blockquote><p>根据bean的类型进行注入，使用autowire=&ldquo;byType"，则寻找与属性名字相同的bean，通过属性的setter方法注入：</p></blockquote>

<pre><code>&lt;bean id="saveVideoInfoDao" class="org.dao.SaveVideoInfoDao"/&gt;
&lt;bean id="videoService" class="org.service.VideoService" autowire="byType"/&gt;
</code></pre>

<h3>6. 通过factory-method给单例类定义bean</h3>

<blockquote><p>如果类的构造函数不可用，比如单例类，构造函数私有，通过public的接口获取实例；定义单例类的bean时，使用<code>factory-method</code>，表示调用类的静态方法构造实例：</p></blockquote>

<pre><code>&lt;bean id="singleton" class="yousharp.Singleton" factory-method="getInstance"/&gt;
&lt;bean id="factoryService" class="yousharp.FactoryService"&gt;
    &lt;constructor-arg name="singleton" ref="singleton"/&gt;
&lt;/bean&gt;
</code></pre>

<h3>7. 定义bean的作用域</h3>

<blockquote><p>默认是singleton，可以设置scope属性为prototype，表示每次调用都创建一个新实例：</p></blockquote>

<pre><code>&lt;bean id="videoInfoServiceImpl" class="com.sohu.tv.service.impl.VideoInfoServiceImpl"
    scope="prototype"/&gt;
</code></pre>

<h3>8. 装配list</h3>

<blockquote><p>数组或Collection的任意实现如List, ArrayList等都可以使用list和set来装配，区别在于set中不允许有重复元素。定义list成员的setter方法：</p></blockquote>

<pre><code>private List&lt;VideoInfoDao&gt; videoInfoDaoList;

public void setVideoInfoDaoList(List&lt;VideoInfoDao&gt; videoInfoDaoList) {
    this.videoInfoDaoList = videoInfoDaoList;
}
</code></pre>

<blockquote><p>在xml配置文件里，在<code>property</code>里定义<code>list</code>，给list成员注入实例：</p></blockquote>

<pre><code>&lt;bean id="videoInfoServiceImpl" class="com.sohu.tv.service.impl.VideoInfoServiceImpl"&gt;
    &lt;property name="videoInfoDaoList"&gt;
        &lt;list&gt;
            &lt;ref bean="jdbcDaoImple"/&gt;
            &lt;ref bean="mybatisDaoImpl"/&gt;
            &lt;ref bean="hibernateDaoImpl"/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>

<h3>9. 装配map</h3>

<blockquote><p>如果需要对一个map成员变量进行注入，在<code>property</code>里，通过<code>map</code>来实现注入，其中key和value都可以是值类型或引用类型；</p></blockquote>

<pre><code>private Map&lt;String, VideoInfoDaoImpl&gt; videoInfoDaoMap ;

public void setVideoInfoDaoList(Map&lt;String, VideoInfoDaoImpl&gt; videoInfoDaoMap) {
    this.videoInfoDaoMap = videoInfoDaoMap;
}

&lt;bean id="videoInfoServiceImpl" class="com.sohu.tv.service.impl.VideoInfoServiceImpl"&gt;
    &lt;property name="videoInfoDaoList"&gt;
        &lt;map&gt;
            &lt;entry key="jdbc" value-ref="videoInfoDaoImpl"/&gt;
            &lt;entry key="mybatis" value-ref="videoInfoDaoImpl"/&gt;
            &lt;entry key="hibernate" value-ref="videoInfoDaoImpl"/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>

<h3>10. 装配property</h3>

<blockquote><p>property也是key-value对，与map的区别是，其key和value必须都是String类型。</p></blockquote>

<pre><code>Properties props;
public void setProps(Properties props) {
    this.props = props;
}

&lt;bean id="videoInfoServiceImpl" class="com.sohu.tv.service.impl.VideoInfoServiceImpl" &gt;
    &lt;property name="props"&gt;
        &lt;props&gt;
            &lt;prop key="daily"&gt;30 00 * * *&lt;/prop&gt;
            &lt;prop key="weekly"&gt;30 00 * * 1&lt;/prop&gt;
            &lt;prop key="monthly"&gt;30 00 * 1 *&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
]]></content>
  </entry>
  
</feed>
