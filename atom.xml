<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[You Sharp]]></title>
  <link href="http://nkcoder.github.io/atom.xml" rel="self"/>
  <link href="http://nkcoder.github.io/"/>
  <updated>2014-04-11T08:27:46+08:00</updated>
  <id>http://nkcoder.github.io/</id>
  <author>
    <name><![CDATA[lingguo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Jetty9作为Linux服务配置记录]]></title>
    <link href="http://nkcoder.github.io/blog/20140411/jetty-as-linux-service/"/>
    <updated>2014-04-11T08:04:08+08:00</updated>
    <id>http://nkcoder.github.io/blog/20140411/jetty-as-linux-service</id>
    <content type="html"><![CDATA[<p>最近将项目都升级到了Jetty 9 和JDK 7，记录一下配置的过程。以下配置基于的版本为：</p>

<ul>
<li>Jetty：9.1.1.v20140108</li>
<li>JDK：1.7.0_51</li>
<li>官方文档版本：2014-03-17T10:14:41-05:00</li>
</ul>


<h3>1. 作为root用户配置</h3>

<p>如果你希望以root用户启动jetty。并将jetty配置为服务，以下为快速通道：</p>

<h4>1.1 将脚本jetty.sh拷贝init.d目录下</h4>

<pre><code># cp bin/jetty.sh /etc/init.d/jetty
</code></pre>

<blockquote><p>jetty.sh是jetty的启动脚本。</p></blockquote>

<h4>1.2 配置/etc/default/jetty</h4>

<pre><code># vim /etc/default/jetty
---------------------------------------------------
PATH=$PATH:/usr/local/jdk1.7.0_51/bin 
JETTY_HOME=/usr/local/jetty9.1 
TMPDIR=/usr/local/jetty9.1/tmp
---------------------------------------------------
</code></pre>

<blockquote><p>jetty.sh脚本会将/etc/default/下同名的文件作为其配置文件。需要配置几个环境变量：主要是java和jetty的根目录，以及指定一个目录作为jetty解压war包时的临时目录，默认是/tmp（不够安全，因为系统服务可能会不定时删除/tmp目录）。</p></blockquote>

<h4>1.3 启动与关闭</h4>

<pre><code># service jetty start
# service jetty stop
</code></pre>

<blockquote><p>init.d目录下的jetty就是服务名.
参考：<a href="http://www.eclipse.org/jetty/documentation/current/startup-unix-service.html">Startup a Unix Service using jetty.sh</a></p></blockquote>

<h3>2. 作为普通用户配置</h3>

<p>如果你希望以普通用户运行jetty，并且可以灵活扩展到多工程的部署，同时jetty升级方便，可以参考一下步骤。</p>

<h4>2.1 配置工程目录</h4>

<p>新建工程目录vrs-base</p>

<pre><code>[root@localhost www]# mkdir vrs-base
[root@localhost www]# cd vrs-base/
[root@localhost www]# mkdir tmp
[root@localhost vrs-base]# pwd
/opt/www/vrs-base
</code></pre>

<p>配置jetty环境</p>

<pre><code>[root@localhost vrs-base]# cp $JETTY_HOME/start.ini /opt/www/vrs-base
[root@localhost vrs-base]# java -jar $JETTY_HOME/start.jar --add-to-start=http,deploy,logging
</code></pre>

<p>修改端口</p>

<pre><code>[root@localhost vrs-base]# grep port start.ini 
jetty.port=8080 
</code></pre>

<h4>2.2 配置服务脚本和属性</h4>

<pre><code>[root@localhost www]# cp $JETTY_HOME/bin/jetty.sh /etc/init.d/jetty-vrs
[root@localhost www]# vim /etc/default/jetty-vrs
---------------------------------------------------
PATH=$PATH:/usr/local/jdk1.7.0_51/bin 
JETTY_HOME=/usr/local/jetty9.1 
JETTY_BASE=/opt/www/vrs-base
TMPDIR=/opt/www/vrs-base/tmp
---------------------------------------------------
</code></pre>

<blockquote><p>JETTY_HOME环境变量表示jetty的安装根目录，JETTY_BASE环境变量表示当前应用的根目录，TEPDIR表示应用被jetty解压后的临时目录，不建议使用默认的/tmp目录。</p></blockquote>

<h4>2.3 应用部署</h4>

<pre><code>[root@localhost vrs-base]# cp /opt/www/vrs.xml /opt/www/vrs-base/webapps/
[root@localhost vrs-base]# cp /opt/www/vrs.war /opt/www/vrs-base/webapps/
</code></pre>

<blockquote><p>将应用的xml配置文件和war包放到$JETTY_BASE/webapps目录中，jetty对该目录下的内容进行自动部署和扫描。</p></blockquote>

<h4>2.4 新建用户/修改权限</h4>

<pre><code># useradd -U www 
# chown -R www $JETTY_HOME
# chown -R www /opt/www
# chown -R www /opt/logs
</code></pre>

<blockquote><p><strong>注意</strong>：所有jetty会访问的目录都需要修改权限，如：排行榜系统在/opt/rank目录下生成文件，则该目录也需要修改为www用户权限。</p></blockquote>

<h4>2.5 启动与停止</h4>

<pre><code>[root@localhost vrs-base]# su - www service jetty-vrs start
Starting Jetty: 2014-04-04 10:17:58.452:INFO::main: Redirecting stderr/stdout to /opt/www/vrs-base/logs/2014_04_04.stderrout.log
. . . . OK Fri Apr  4 10:18:17 CST 2014 

[root@localhost vrs-base]# ps -ef | grep jetty
www       2821     1 65 10:19 pts/1    00:00:15 /usr/local/jdk1.7.0_51/bin/java -Djetty.state=/opt/www/vrs-base/jetty-vrs.state -Djetty.logs=/opt/www/vrs-base/logs -Djetty.home=/usr/local/jetty9.1 -Djetty.base=/opt/www/vrs-base -Djava.io.tmpdir=/opt/www/vrs-base/tmp -jar /usr/local/jetty9.1/start.jar jetty-logging.xml jetty-started.xml
root      2887  1929  0 10:19 pts/1    00:00:00 grep jetty

[root@localhost vrs-base]# su - www service jetty-vrs stop
Stopping Jetty: OK
</code></pre>

<h4>2.6 多应用部署</h4>

<p>可以使用同一个jetty，启动多个实例，每个实例部署一个应用，并作为服务运行。
重复2.1~2.5的步骤，只需要再定义一个JETTY_BASE，在/etc/init.d目录下添加一个对应的服务名即可。
即：将2.1中的vrs-base修改为ugc-base，将2.2中的jetty-vrs修改为jetty-ugc，启动和停止：</p>

<pre><code>$ su - www service jetty-ugc start
$ su - www service jetty-ugc stop
</code></pre>

<h4>附录</h4>

<p>xml配置文件示例(feedback.xml):</p>

<pre><code>&lt;?xml version="1.0"  encoding="UTF-8"?&gt;
&lt;!DOCTYPE Configure PUBLIC "-//Jetty//Configure//EN" "http://www.eclipse.org/jetty/configure_9_0.dtd"&gt;

&lt;Configure class="org.eclipse.jetty.webapp.WebAppContext"&gt;

  &lt;Set name="contextPath"&gt;/&lt;/Set&gt;
  &lt;Set name="war"&gt;/opt/www/feedback-base/webapps/feedback.war&lt;/Set&gt;
  &lt;Set name="tempDirectory"&gt;/opt/www/feedback-base/tmp&lt;/Set&gt;
  &lt;Set name="persistTempDirectory"&gt;true&lt;/Set&gt;

   &lt;Set name="handler"&gt;
    &lt;New id="RequestLog" class="org.eclipse.jetty.server.handler.RequestLogHandler"&gt;
      &lt;Set name="requestLog"&gt;
        &lt;New id="RequestLogImpl" class="org.eclipse.jetty.server.NCSARequestLog"&gt;
          &lt;Set name="filename"&gt;&lt;Property name="jetty.logs" default="./logs"/&gt;/feedback-yyyy_mm_dd.request.log&lt;/Set&gt;
          &lt;Set name="filenameDateFormat"&gt;yyyy_MM_dd&lt;/Set&gt;
          &lt;Set name="LogTimeZone"&gt;Asia/Shanghai&lt;/Set&gt;
          &lt;Set name="retainDays"&gt;60&lt;/Set&gt;
          &lt;Set name="append"&gt;true&lt;/Set&gt;
        &lt;/New&gt;
      &lt;/Set&gt;
    &lt;/New&gt;
  &lt;/Set&gt;

&lt;/Configure&gt;
</code></pre>

<p>/etc/default目录下的配置文件示例(jetty-feedback)：</p>

<pre><code>JAVA=/usr/local/jdk7/bin/java
JETTY_HOME=/usr/local/jetty9
JETTY_BASE=/opt/www/feedback-base
TMPDIR=/opt/www/feedback-base/tmp   
</code></pre>

<p>启动/停止脚本示例(jettyctl.sh)</p>

<pre><code># usage
usage()
{
    echo "Usage: ${0##*/} {start|stop|status|restart}"
    exit 1
}

# need one param
if [ $# -lt 1 ]; then
    usage
fi

action=$1

# control jetty
case "$action" in
    start)
        su - www service jetty-vrs start
    ;;
    stop)
        su - www service jetty-vrs stop
    ;;
    status)
        su - www service jetty-vrs status
    ;;
    restart)
        su - www service jetty-vrs restart
    ;;
    *)  
        usage
    ;;
esac
</code></pre>

<h4>参考</h4>

<ul>
<li><a href="http://www.eclipse.org/jetty/documentation/current/startup-unix-service.html">Startup a Unix Service using jetty.sh</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring持久化之Hibernate]]></title>
    <link href="http://nkcoder.github.io/blog/20140330/spring-hibernate-example/"/>
    <updated>2014-03-30T18:37:27+08:00</updated>
    <id>http://nkcoder.github.io/blog/20140330/spring-hibernate-example</id>
    <content type="html"><![CDATA[<p>本文简要介绍Spring通过Hibernate实现持久化需要的基本配置，分别通过注解和xml配置来实现。</p>

<h3>1. 通过注解实现</h3>

<h4>1.1 添加pom依赖</h4>

<p>在pom的xml里添加<em>Hibernate</em>相关的依赖，如：</p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;
    &lt;version&gt;3.6.10.Final&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;javax.persistence&lt;/groupId&gt;
    &lt;artifactId&gt;persistence-api&lt;/artifactId&gt;
    &lt;version&gt;${javax.persist}&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;javassist&lt;/groupId&gt;
    &lt;artifactId&gt;javassist&lt;/artifactId&gt;
    &lt;version&gt;3.12.1.GA&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<h4>1.2 实体类的注解定义</h4>

<p>先定义一个实体类StudentEntity.java，映射到数据库中的表students：</p>

<pre><code>@Entity
@Table(name = "students")
public class StudentEntity {
    @Id
    @Column(name = "id", nullable = false)
    @GeneratedValue
    private int id;

    @Column(name = "name", nullable = false)
    private String name;

    @Column(name = "sex", nullable = true)
    private String sex;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }

    public StudentEntity() {}

    public StudentEntity(String name, String sex) {
        this.name = name;
        this.sex = sex;
    }
}
</code></pre>

<blockquote><p><strong>@Entity</strong>表示这是一个实体类，<strong>@Table(name = &ldquo;students&rdquo;)</strong>表示映射到数据源指定的数据库中的一个名为<em>students</em>的表；<strong>@Id</strong>表示该字段是主键，<strong>@Column(name = &ldquo;id&rdquo;, nullable = false)</strong>表示该属性映射到表中名为<em>id</em>的属性，且不能为空；<strong>@GeneratedValue</strong>表示该字段是自增的；这样定义之后，该实体类便与表<em>students</em>完成了一一对应。</p></blockquote>

<h4>1.3 定义dao实现类</h4>

<p>我们的dao实现类为HibernateDaoImpl.java，依赖一个属性，即<em>SessionFactory</em>的实例，我们通过注解实现注入：</p>

<pre><code>@Repository (value = "hibernateDaoImpl")
public class HibernateDaoImpl implements StudentDao {

    @Resource(name = "sessionFactory")
    SessionFactory sessionFactory;

    @Override
    @Transactional
    public StudentEntity getUserNameById(int id) {
        StudentEntity studentEntity = (StudentEntity) sessionFactory.getCurrentSession().get(StudentEntity.class, id);
        return studentEntity;
    }

    @Override
    @Transactional
    public void saveStudents(StudentEntity studentEntity) {
        sessionFactory.getCurrentSession().persist(studentEntity);
    }
}
</code></pre>

<blockquote><p><strong>Repository</strong>注解表示该类会被Spring的注解扫描器自动定义为bean，bean的名字为<em>hibernateDaoImpl</em>，同时实现异常转换，将Hibernate的检查型异常，转换为Spring的非检查型异常，这是通过在Spring配置文件里配置<strong>PersistenceExceptionTranslationPostProcessor</strong>的ban实现的。通过<em>sessionFactory</em>的<em>getCurrentSession</em>方法获取当前的<em>session</em>，实现对数据库的持久化操作。Hibernate还要求这些操作是与事务绑定的，因此需要在dao层或者service层添加事务的注解，即<em>@Transactional</em>。</p></blockquote>

<h4>1.4 添加Spring配置</h4>

<p>在Spring配置文件applicationContext.xml主要是添加<strong>SessionFactory</strong>的配置，以及配置事务，与<em>Hibernate</em>相关的配置如下：</p>

<pre><code>&lt;bean name="sessionFactory" class="org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean"&gt;
    &lt;property name="dataSource" ref="feedbackDataSource"/&gt;
    &lt;property name="packagesToScan" value="com.sohu.tv.bean"/&gt;
    &lt;property name="hibernateProperties"&gt;
        &lt;props&gt;
            &lt;prop key="hibernate.dialect"&gt;org.hibernate.dialect.MySQL5Dialect&lt;/prop&gt;
            &lt;prop key="hibernate.show_sql"&gt;true&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean class="org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor"/&gt;

&lt;bean id="tx" class="org.springframework.orm.hibernate3.HibernateTransactionManager"&gt;
    &lt;property name="sessionFactory" ref="sessionFactory"/&gt;
&lt;/bean&gt;

&lt;tx:annotation-driven transaction-manager="tx"/&gt;
</code></pre>

<blockquote><p>在定义<em>sessionFactory</em>的bean时，因为是基于注解的，所以引用的class为：<strong>AnnotationSessionFactoryBean</strong>；属性<em>dataSource</em>即配置的数据源；属性<em>packagesToScan</em>即要扫描的包名，在这个包下的所有类，如果使用了<em>@Entity</em>、<em>@Column</em>等注解，都会被扫描器处理；<em>@hibernateProperties</em>属性定义了Hibernate相关的属性，如使用的dialect，是否显示输出sql语句等。<strong>PersistenceExceptionTranslationPostProcessor</strong>定义的bean是进行异常转换的；<em>HibernateTransactionManager</em>用于定义事务；<em>&lt;tx:annotation-driven /></em>类似于<em>&lt;context:component-scan /></em>，扫描事务类型的注解。</p></blockquote>

<h3>2. 通过xml映射文件实现</h3>

<p>通过xml映射文件与通过注解实现的区别就在于实体类与数据库之间的映射的定义，所以其它相同的部分就不重复了。</p>

<h4>2.1 定义映射文件</h4>

<p>这个映射文件定义实体类与数据库的表之间的映射，即属性与字段的映射，如hibernate.xml文件内容可以如下定义：</p>

<pre><code>&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;
&lt;hibernate-mapping&gt;
    &lt;class name="com.sohu.tv.bean.Students" table="students"&gt;

        &lt;id name="id" type="int"&gt;
            &lt;column name="id" /&gt;
            &lt;generator class="identity" /&gt;
        &lt;/id&gt;
        &lt;property name="name" type="string"&gt;
            &lt;column name="name" length="255" not-null="true" /&gt;
        &lt;/property&gt;
        &lt;property name="sex" type="string"&gt;
            &lt;column name="sex" not-null="false" /&gt;
        &lt;/property&gt;
    &lt;/class&gt;
&lt;/hibernate-mapping&gt;
</code></pre>

<h4>2.2 修改Spring配置文件</h4>

<p>需要修改的是<em>sessionFactory</em>的bean的定义，如：</p>

<pre><code>&lt;bean name="sessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt;
    &lt;property name="dataSource" ref="feedbackDataSource"/&gt;
    &lt;property name="mappingLocations"&gt;
        &lt;list&gt;
            &lt;value&gt;classpath*:hibernate.xml&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="hibernateProperties"&gt;
        &lt;props&gt;
            &lt;prop key="hibernate.dialect"&gt;org.hibernate.dialect.MySQL5Dialect&lt;/prop&gt;
            &lt;prop key="hibernate.show_sql"&gt;true&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>

<blockquote><p>将<strong>AnnotationSessionFactoryBean</strong>修改为<strong>LocalSessionFactoryBean</strong>，同时，需要将属性<em>packagesToScan</em>修改为<em>mappingLocations</em>，即xml映射文件的位置。</p></blockquote>

<h4>参考：</h4>

<ul>
<li><a href="http://book.douban.com/subject/24714203/">Spring 实战</a></li>
<li><a href="http://www.mkyong.com/struts/struts-spring-hibernate-integration-example/">Struts + Spring + Hibernate Integration Example</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[elasticsearch查询api：match query]]></title>
    <link href="http://nkcoder.github.io/blog/20140323/elasticsearch-match-query/"/>
    <updated>2014-03-23T22:55:03+08:00</updated>
    <id>http://nkcoder.github.io/blog/20140323/elasticsearch-match-query</id>
    <content type="html"><![CDATA[<h3>1. match query</h3>

<ul>
<li>与<strong>term query</strong>不同，<strong>match query</strong>的查询词是被分词处理的（analyzed），即首先分词，然后构造相应的查询，所以应该确保查询的分词器和索引的分词器是一致的；</li>
<li>与<strong>terms query</strong>相似，提供的查询词之间默认是or的关系，可以通过<code>operator</code>属性指定；</li>
<li><strong>match query</strong>有两种形式，一种是简单形式，一种是bool形式；</li>
</ul>


<h3>2. REST API</h3>

<pre><code># curl -XGET 'localhost:9200/video/video_info/_search?pretty' -d @match_query.json
</code></pre>

<p>简单形式的<strong>match query</strong>：</p>

<pre><code>{
    "query": {
        "match": {
            "tvName": "决战"
        }
    }
}
</code></pre>

<p>bool形式的<strong>match query</strong>：</p>

<pre><code>{
    "query": {
        "match": {
            "tvName": {
                "query": "决战华岩寺",
                "operator": "or",
                "minimum_should_match": "2"
            }
        }
    }
}
</code></pre>

<blockquote><p>在REST API中，<code>tvName</code>表示要查询的目标字段，也可以是<code>_all</code>。bool形式的<strong>match query</strong>支持的属性有：</p></blockquote>

<ul>
<li><code>operator</code>: 指定构造查询时的布尔操作，可以是<code>and</code>、<code>or</code>，默认是<code>or</code>；</li>
<li><code>analyzer</code>：指定查询分词器，默认为默认的分词器；</li>
<li><code>minimum_should_match</code>: 最小匹配个数</li>
</ul>


<h3>3. Java API</h3>

<p>以下为<strong>match query</strong>的Java API示例：</p>

<pre><code>public static void matchQuery() {
    String queryWord = "天津电视台";
    QueryBuilder matchQuery = QueryBuilders.matchQuery(ConstantUtil.FIELD_TV_NAME, queryWord)
            .analyzer("ik").operator(MatchQueryBuilder.Operator.OR).minimumShouldMatch("1");
    SearchResponse response = searchRequestBuilder.setQuery(matchQuery)
            .setFrom(0).setSize(5).execute().actionGet();
    printResult(response);
}
</code></pre>

<h3>4. 看看Java源码</h3>

<pre><code>public static MatchQueryBuilder matchQuery(String name, Object text) {
    return new MatchQueryBuilder(name, text).type(MatchQueryBuilder.Type.BOOLEAN);
}
</code></pre>

<blockquote><p><strong>match query</strong>对应的是<code>matchQuery()</code>函数，内部先调用<code>MatchQueryBuilder</code>的构造函数，然后将类型设置为<em>Boolean</em>，即先分词，然后构造布尔查询；</p></blockquote>

<h4>5. 参考：</h4>

<ul>
<li><a href="http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-match-query.html">match query</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring持久化之MyBatis]]></title>
    <link href="http://nkcoder.github.io/blog/20140322/spring-mybatis/"/>
    <updated>2014-03-22T20:12:52+08:00</updated>
    <id>http://nkcoder.github.io/blog/20140322/spring-mybatis</id>
    <content type="html"><![CDATA[<p>MyBatis是一个优秀的轻量级持久化框架，本文主要介绍MyBatis与Spring集成的配置与用法。</p>

<h3>1. Spring MyBatis配置</h3>

<h3>1.1 添加Maven依赖</h3>

<p>在pom.xml文件里添加mybatis-spring和mybatis的依赖：</p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
    &lt;version&gt;${mybatis.spring.version}&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
    &lt;version&gt;${mybatis.version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<blockquote><p>mybatis-spring当前最新版本为1.2.2，mybatis当前版本是3.2.5.</p></blockquote>

<h3>1.2 添加dao接口</h3>

<p>这里的dao必须是接口，而不是具体的实现，如MyBatisDao.java内容为：</p>

<pre><code>public interface MyBatisTest {

    public String getUserNameById(int id);

    public List&lt;Students&gt; getStudentByNumAndCity(Map&lt;String, Object&gt; queryMap);
}
</code></pre>

<blockquote><p>接口中定义的每一个方法对应于mapper映射文件中定义的jdbc执行模块，如<code>&lt;select/&gt;</code>、<code>&lt;update/&gt;</code>、<code>&lt;insert/&gt;</code>等。</p></blockquote>

<h3>1.3 添加mybatis配置文件</h3>

<p>该配置文件里主要配置类型别名<code>&lt;typeAliases/&gt;</code>、设置<code>&lt;settings/&gt;</code>，mapper映射文件路径<code>&lt;mappers/&gt;</code>也可以放在这里，但更建议将所有的mapper文件都放在一个目录下，在定义<code>sqlSessionFactory</code>时通过属性<code>mapperLocations</code>指定。如mybatis.xml配置文件可以如下定义：</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;

&lt;configuration&gt;
    &lt;typeAliases&gt;
        &lt;typeAlias type="com.sohu.tv.bean.Students" alias="Students"/&gt;
    &lt;/typeAliases&gt;

    &lt;!--&lt;mappers&gt;--&gt;
        &lt;!--&lt;mapper resource="com/sohu/tv/mapper/MybatisTest.xml"/&gt;--&gt;
    &lt;!--&lt;/mappers&gt;--&gt;

&lt;/configuration&gt;
</code></pre>

<blockquote><p>类型别名是用别名来代表全限定类名，如在需要用到com.sohu.tv.bean.Students的地方，都可以使用Students来代替。</p></blockquote>

<h3>1.4 添加mapper映射文件：</h3>

<p>mapper映射文件可以定义数据库列与POJO类属性的映射，以及与dao接口类中的方法对应的JDBC执行模块，如MyBatisMapper.xml的内容为：</p>

<pre><code>&lt;mapper namespace="com.sohu.tv.dao.MyBatisTest"&gt;
    &lt;resultMap id="studentMap" type="Students"&gt;
        &lt;result column="name" property="name"/&gt;
        &lt;result column="sex" property="sex"/&gt;
        &lt;result column="number" property="number"/&gt;
        &lt;result column="enable" property="enable"/&gt;
        &lt;result column="city" property="city"/&gt;
    &lt;/resultMap&gt;

    &lt;select id="getUserNameById" parameterType="int" resultType="String"&gt;
        select name from students where id = #{id}
    &lt;/select&gt;

    &lt;select id="getStudentByNumAndCity" parameterType="map" resultMap="studentMap"&gt;
        select * from students where number = #{num} and city = #{city}
    &lt;/select&gt;

&lt;/mapper&gt;
</code></pre>

<blockquote><p><code>&lt;resultMap/&gt;</code>即定义列与属性的字段映射；<code>&lt;select/&gt;</code>中的参数和返回值的类型，既可以为基本类型，如string，int，long，也可以是map，返回类型还可以是<code>&lt;resultMap/&gt;</code>定义的映射map；如果参数类型是map，则sql中的参数名（如#{num})必须是map的key；如果返回类型为map，则sql语句中返回的列名为key；如果是基本类型，使用type，如parameterType，resultType，如果是自定义map，使用parameterMap，resultMap.</p></blockquote>

<h3>1.5 Spring配置文件的配置</h3>

<p>首先需要配置sqlSessionFactory：</p>

<pre><code>&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;
    &lt;property name="dataSource" ref="feedbackDataSource"/&gt;
    &lt;property name="configLocation" value="classpath:mybatis.xml"/&gt;
    &lt;property name="mapperLocations" value="classpath:com/sohu/tv/mapper/*.xml"/&gt;
&lt;/bean&gt;
</code></pre>

<blockquote><p>属性<code>dataSource</code>引用JDBC数据源；属性<code>configLocation</code>指定mybatis配置文件的位置，配置文件中定义别名<code>&lt;typeAliases/&gt;</code>，设置<code>&lt;settings/&gt;</code>等。<code>mapperLocations</code>指定mapper映射文件的路径。有一点需要注意的是，要确保mapper映射文件被打包进classpath中，默认情况下，maven会忽略源文件中的资源文件，可以通过在pom文件中配置，使得资源文件被一起打包进classpath中；如在pom配置文件中添加：</p></blockquote>

<pre><code>&lt;build&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/java&lt;/directory&gt;
            &lt;excludes&gt;&lt;exclude&gt;**/*.java&lt;/exclude&gt;&lt;/excludes&gt;
        &lt;/resource&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/resources&lt;/directory&gt;
            &lt;filtering&gt;true&lt;/filtering&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/build&gt;
</code></pre>

<p>其次，需要定义与dao接口相关联的mapperFactoryBean：</p>

<pre><code>&lt;bean id="mybatisDaoImpl" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt;
    &lt;property name="mapperInterface" value="com.sohu.tv.dao.MyBatisTest"/&gt;
    &lt;property name="sqlSessionFactory" ref="sqlSessionFactory"/&gt;
&lt;/bean&gt;
</code></pre>

<blockquote><p><code>mapperInterface</code>属性的值为相关的dao接口，<code>sqlSessionFactory</code>属性引用了上述定义的sqlSessionFacotry；</p></blockquote>

<h3>1.6 service类中调用dao类实现业务逻辑</h3>

<p>在MyBatisServiceImpl.java中使用dao接口中提供的方法：</p>

<pre><code>@Resource(name = "mybatisDaoImpl")
MyBatisDao myBatisDaoImpl;

String userName = mybatisDaoImpl.getUserNameById(2);
System.out.println(userName);

Map&lt;String, Object&gt; queryMap = new HashMap&lt;String, Object&gt;();
queryMap.put("num", 333);
queryMap.put("city", "beijing");
List&lt;Students&gt; studentsList = mybatisDaoImpl.getStudentByNumAndCity(queryMap);
for (Students students: studentsList) {
    System.out.println(students.getName());
}
</code></pre>

<h3>2. 启动自动扫描注解</h3>

<p>我们可以在applicationContext.xml配置文件里为每个dao接口定义bean，但mybatis还提供了一种更简便的自动扫描注解的机制，即<code>&lt;mybatis:scan/&gt;</code>和<code>&lt;MapperScannerConfigurer/&gt;</code>。
配置<code>&lt;mybatis:scan/&gt;</code>，需要在applicationContext.xml配置文件里添加：</p>

<pre><code>&lt;mybatis:scan base-package="com.sohu.tv.dao"/&gt;
</code></pre>

<blockquote><p><code>&lt;mybatis:scan/&gt;</code>与Spring的<code>&lt;context:component-scan/&gt;</code>非常相似，<code>base-package</code>指定要扫描的包，并将包下的所有接口注册为对应的bean。命名规则：和Spring一样，如果该接口没有被注解，则bean的名称为首字母小写的非限定类名，如接口为<code>com.sohu.tv.dao.MyBatisDao</code>，则bean的名字为<code>myBatisDao</code>；如果dao接口使用了Spring的注解，如@Component或@Named等注解，并提供了bean的名称，则mybatis使用该注解的名称作为bean的名称。如将MyBatisDao接口重定义如下：</p></blockquote>

<pre><code>@Repository(value = "mybatisDao")
public interface MyBatisDao {

    public String getUserNameById(int id);

    public List&lt;Students&gt; getStudentByNumAndCity(Map&lt;String, Object&gt; queryMap);
}
</code></pre>

<blockquote><p>测试MyBatisDao被自动注解后的bean的名称为mybatisDao。建议通过注解指定bean的名称，防止类类名的变化导致了bean名称的变化；</p></blockquote>

<p>配置<code>&lt;MapperScannerConfigurer/&gt;</code>，需要在applicationContext.xml中添加：</p>

<pre><code>&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt;
    &lt;property name="basePackage" value="com.sohu.tv.dao"/&gt;
    &lt;property name="sqlSessionFactoryBeanName" value = "sqlSessionFactory"/&gt;
&lt;/bean&gt;
</code></pre>

<blockquote><p>这里的<code>basePackage</code>与<code>&lt;mybatis:scan/&gt;</code>的<code>base-package</code>的含义一致，bean的命名规则也是一样的，所以这两种方式等价。</p>

<p>如果启动了自动扫描注解，则在spring配置文件中不再需要dao接口的bean定义了。</p></blockquote>

<h3>3. 总结-最佳实践</h3>

<ul>
<li>mapper映射文件放在单独的目录中，统一管理，在配置<code>sqlSessionFactory</code>时，通过属性<code>mapperLocations</code>指定；</li>
<li>mybatis配置文件中只定义<code>typeAliases</code>、<code>settings</code>等配置信息；</li>
<li>Spring配置文件中，通过<code>&lt;mybatis:scan/&gt;</code>或者<code>&lt;MapperScannerConfigurer/&gt;</code>启动自动注解，并通过Spring的注解对bean命名。</li>
</ul>


<h4>参考资料：</h4>

<ul>
<li><ol>
<li><a href="http://mybatis.github.io/spring/index.html">MyBatis-Spring</a></li>
</ol>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[elasticsearch查询api：terms query]]></title>
    <link href="http://nkcoder.github.io/blog/20140320/elasticsearch-terms-query/"/>
    <updated>2014-03-20T08:24:42+08:00</updated>
    <id>http://nkcoder.github.io/blog/20140320/elasticsearch-terms-query</id>
    <content type="html"><![CDATA[<h3>1. terms query查询</h3>

<ul>
<li>提供多个查询词，以数组形式出现，查询指定的字段是否包含其中一个或者多个查询词；</li>
<li>功能与：<strong>bool query</strong>通过对多个term进行<code>should</code>操作的功能是一致的，是更简单的一种语法形式；</li>
<li>提供的查询词也是不分词的，只有完全包含才算匹配；可以通过<code>minimum_should_match</code>属性指定最少匹配的个数；</li>
</ul>


<h3>2. REST API</h3>

<p><strong>terms query</strong>的REST API示例如下：</p>

<pre><code>{
    "query": {
        "terms": {
            "tvName": ["日本", "停电"],
            "minimum_should_match": 1
        }
    }
}
</code></pre>

<blockquote><p>在REST API中，<strong>terms query</strong>使用<code>terms</code>关键字，其中<em>tvName</em>表示要查询的字段，<code>minimum_should_match</code>表示至少要匹配多少个查询词。</p></blockquote>

<h3>3. Java API</h3>

<p><strong>terms query</strong>的Java API示例如下：</p>

<pre><code>public static void termsQuery() {
    String[] queryWords = new String[] {"日本", "停电"};
    QueryBuilder queryBuilder = QueryBuilders.termsQuery(ConstantUtil.FIELD_TV_NAME, queryWords)
            .minimumShouldMatch("2");
    SearchResponse response = searchRequestBuilder.setQuery(queryBuilder)
            .setFrom(0).setSize(5).execute().actionGet();
    printResult(response);
}
</code></pre>

<blockquote><p>在Java API中，<strong>terms query</strong>使用<strong>termsQuery()</strong>函数，除了<strong>minimumShouldMatch()</strong>属性，还有<strong>boost()</strong>和<strong>minimumMatch()</strong>属性。</p></blockquote>

<h3>4. 看看Java源码</h3>

<pre><code>public static TermsQueryBuilder termsQuery(String name, String... values) {
    return new TermsQueryBuilder(name, values);
}

public static TermsQueryBuilder termsQuery(String name, Object... values) {
    return new TermsQueryBuilder(name, values);
}

public static TermsQueryBuilder termsQuery(String name, Collection&lt;?&gt; values) {
    return new TermsQueryBuilder(name, values);
}

public TermsQueryBuilder(String name, Collection values) {
    this(name, values.toArray());
}

public TermsQueryBuilder(String name, Object... values) {
    this.name = name;
    this.values = values;
}
</code></pre>

<blockquote><p><strong>termsQuery()</strong>函数的第二个参数是一个查询词数组，可以是基本类型的数组，可以是Object数组，也可以是一个集合类型；其实，内部都是调用<strong>TermsQueryBuilder</strong>的一个构造函数，即上述的最后一个函数，第二个参数是Object数组；</p></blockquote>

<h4>参考</h4>

<ul>
<li><a href="http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html">terms-query</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[elasticsearch查询api：term query]]></title>
    <link href="http://nkcoder.github.io/blog/20140318/elasticsearch-term-query/"/>
    <updated>2014-03-18T20:46:56+08:00</updated>
    <id>http://nkcoder.github.io/blog/20140318/elasticsearch-term-query</id>
    <content type="html"><![CDATA[<h3>1. term query查询</h3>

<ul>
<li>在给定的字段里查询词或者词组；</li>
<li>提供的查询词是不分词的(not analyzed)，即只有完全包含才算匹配；</li>
<li>支持boost属性，boost可以提高field和document的相关性；</li>
</ul>


<h3>2. REST API</h3>

<pre><code>$ curl -XGET 'localhost:9200/video/video_info/_search?pretty' -d @term_query.json
</code></pre>

<p>term_query.json
简单的字段查询：</p>

<pre><code>{
    "query": {
        "term": {
            "tvName": "童年"
        }
    }
}
</code></pre>

<p>添加boost属性：</p>

<pre><code>{
    "query": {
        "term": {
            "tvName": {
                "value": "童年",
                "boost": 10
            }
        }
    }
}
</code></pre>

<h3>3. Java API</h3>

<pre><code>public static void termQuery() {
    String queryWord = "巨头";
    QueryBuilder queryBuilder = QueryBuilders.termQuery(ConstantUtil.FIELD_TV_NAME, queryWord)
            .boost(10);
    SearchResponse response = searchRequestBuilder.setQuery(queryBuilder)
            .setFrom(0).setSize(5).execute().actionGet();
    printResult(response);
}
</code></pre>

<h3>4. 看看Java源码</h3>

<p>以下是term_query相关的java源码：</p>

<pre><code>public static TermQueryBuilder termQuery(String name, String value) {
    return new TermQueryBuilder(name, value);
}

public static TermQueryBuilder termQuery(String name, int value) {
    return new TermQueryBuilder(name, value);
}

public TermQueryBuilder(String name, Object value) {
    this.name = name;
    this.value = value;
}

public TermQueryBuilder boost(float boost) {
    this.boost = boost;
    return this;
}
</code></pre>

<blockquote><p>从源码可以看到：termQuery方法内部都是调用TermQueryBuilder的构造函数，而TermQueryBuilder有很多重载的构造函数，最主要的就是上面的第三个函数，即第二个参数是Object类型，其它的构造函数都是调用该函数实现的。</p></blockquote>

<h4>参考资料：</h4>

<ul>
<li><a href="http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-term-query.html">elasticsearch-guide</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring持久化之JDBC]]></title>
    <link href="http://nkcoder.github.io/blog/20140316/spring-jdbc/"/>
    <updated>2014-03-16T18:01:26+08:00</updated>
    <id>http://nkcoder.github.io/blog/20140316/spring-jdbc</id>
    <content type="html"><![CDATA[<p>这个小系列介绍Spring的持久化策略，主要关注当前应用最广泛的三种方式：Spring JDBC， MyBatis以及Hibernate。
使用JDBC的优劣如下：</p>

<ul>
<li>优势：相对于持久化框架，使用JDBC，不需要掌握其它框架的查询语言，允许我们在更低的层次上处理数据，能够访问数据库中单独的列，而且能够更好地对数据访问的性能进行调优。</li>
<li>劣势：随着项目的规模和复杂度的提升，使用JDBC会非常繁琐，同时不易于处理复杂的问题。</li>
<li>Spring JDBC：提供数据访问模板，简化JDBC编程，同时提供了平台无关的持久化异常体系。</li>
</ul>


<h3>1. 配置数据源</h3>

<p>在生产环境，考虑到性能，应该使用数据库连接池。以commons dbcp配置为例，配置如下：</p>

<pre><code>&lt;context:property-placeholder location="classpath:jdbc.properties"/&gt;

&lt;bean id="vrsDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="${jdbc.drvier}"/&gt;
    &lt;property name="url" value="${jdbc.videodb.url}"/&gt;
    &lt;property name="username" value="${jdbc.videodb.username}"/&gt;
    &lt;property name="password" value="${jdbc.videodb.password}"/&gt;
    &lt;property name="maxActive" value="${jdbc.videodb.maxActive}"/&gt;
    &lt;property name="initialSize" value="${jdbc.videodb.initialSize}"/&gt;
&lt;/bean&gt;
</code></pre>

<blockquote><p>主要属性参数说明：</p></blockquote>

<ul>
<li>driverClassName: JDBC驱动的全限定类名，如mysql就是：com.mysql.jdbc.Driver；</li>
<li>url：JDBC的url，如使用mysql的url：jdbc:mysql://10.11.132.193:3306/vrs；</li>
<li>username, password: 连接该数据源的用户名和密码；</li>
<li>initialSize：表示初始大小，即连接池启动时创建的连接数量；</li>
<li>maxActive：表示同一时间可从池中分配的最大连接数，0表示无限制；</li>
<li>maxIdle：池里不会被释放的最大连接数，0表示无限制；</li>
<li>minIdle：在不创建新连接的情况下，池中保持空闲的最小连接数；</li>
<li>maxWait：没有可用连接时，在抛出异常之前，池等待连接回收的最大时间；-1表示无线等待；</li>
<li>validationQuery：验证连接的sql查询，至少返回一行；
更多属性参考<a href="http://commons.apache.org/proper/commons-dbcp/configuration.html">wiki页</a></li>
</ul>


<blockquote><p>其它推荐的连接池有：</p></blockquote>

<ul>
<li><a href="http://www.mchange.com/projects/c3p0/">c3p0</a>: 适合多线程环境；</li>
<li><a href="https://github.com/alibaba/druid">druid</a>：完善的监控功能；</li>
</ul>


<h3>2. 使用JdbcTemplate</h3>

<p>使用JdbcTemplate类，在sql语句中，以?作为参数的占位符，传入的参数的顺序与sql语句中?的顺序必须是一一对应的。</p>

<p>首先在xml配置文件里添加jdbcTemplate的bean，其参数<code>dataSource</code>引用之前定义的数据源：</p>

<pre><code>&lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt;
    &lt;property name="dataSource" ref="vrsDataSource"/&gt;
&lt;/bean&gt;
</code></pre>

<p>然后，在dao类中引用JdbcTemplate类，并注入：</p>

<pre><code>@Resource(name = "jdbcTemplate")
JdbcTemplate jdbcTemplate;
</code></pre>

<p>查询
返回基本类型：</p>

<pre><code>String getUserById = "select name from students where id = ?";
String userName = jdbcTemplate.queryForObject(getUserById, new Object[]{3}, String.class);
</code></pre>

<p>返回<code>Map&lt;String, Object&gt;</code>，key为列名，value为对应列的值，此时返回值只能有一行，否则报错：</p>

<pre><code>String getStudentByNumber = "select * from students where number = ?";
Map&lt;String, Object&gt; studentMap = jdbcTemplate.queryForMap(getStudentByNumber, 111);
</code></pre>

<p>返回<code>List&lt;Map&lt;String, Object&gt;&gt;</code>, 可以返回多列：</p>

<pre><code>String getStudentsByCity = "select * from students where city = ?";
List&lt;Map&lt;String, Object&gt;&gt; studentList = jdbcTemplate.queryForList(getStudentsByCity, "tianjin");
</code></pre>

<p>返回自定义class的对象，需要实现RowMapper接口，定义列名和属性的映射：
首先实现RowMapper接口：</p>

<pre><code>public class StudentRowMapper implements RowMapper&lt;Students&gt; {
    @Override
    public Students mapRow(ResultSet rs, int rowNum) throws SQLException {
        Students students = new Students();
        students.setId(rs.getInt("id"));
        students.setName(rs.getString("name"));
        students.setSex(rs.getString("sex"));
        students.setNumber(rs.getInt("number"));
        students.setEnable(rs.getInt("enable"));
        students.setCity(rs.getString("city"));
        return students;
    }
}
</code></pre>

<p>然后，使用query或者queryForObject查询多行或一行：</p>

<pre><code>String getStudentsByCity = "select * from students where city = ?";
List&lt;Students&gt; studentsList = jdbcTemplate.query(getStudentsByCity, new StudentRowMapper(), "tianjin");
</code></pre>

<h3>2. 使用NamedParameterJdbcTemplate</h3>

<p>使用NamedParameterJdbcTemplate类，sql语句中的参数是以命名的变量来表示，传入参数时，只要参数名一致即可，索引位置不必一一对应。
首先在xml配置文件里定义NamedParameterJdbcTemplate的bean：</p>

<pre><code>&lt;bean id="namedParameterJdbcTemplate" class="org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate"&gt;
    &lt;constructor-arg name="dataSource" ref="feedbackDataSource"/&gt;
&lt;/bean&gt;
</code></pre>

<p>然后将namedParameterJdbcTemplate bean注入到dao中，</p>

<pre><code>@Resource(name = "namedParameterJdbcTemplate")
NamedParameterJdbcTemplate namedParameterJdbcTemplate;
</code></pre>

<p>定义sql，参数以(:变量名)形式给出即可，如：</p>

<pre><code>String getStudentByNumber = "select * from students where number = (:number) and city = (:city)";
NamedParameterJdbcTemplate namedParameterJdbcTemplate = (NamedParameterJdbcTemplate) context.getBean("namedParameterJdbcTemplate");
Map&lt;String, Object&gt; queryMap = new HashMap&lt;String, Object&gt;();
queryMap.put("number", 333);
queryMap.put("city", "tianjin");
List&lt;Map&lt;String, Object&gt;&gt; mapList = namedParameterJdbcTemplate.queryForList(getStudentByNumber, queryMap);
</code></pre>

<blockquote><p>除了使用命名参数外，NamedParameterJdbcTemplate与JdbcTempate的主要用法都是一致的。</p></blockquote>

<h3>3. 使用JdbcDaoSupport</h3>

<p>JdbcDaoSupport是一个父类，如果有多个dao类，通过继承JdbcDaoSupport，可以更方便地获取jdbcTemplate。
首先让dao类继承JdbcDaoSupport类：</p>

<pre><code>public class InfoJdbcImpl extends JdbcDaoSupport implements VideoInfoDao {
</code></pre>

<p>然后在定义dao类的bean时，注入一个<code>jdbcTemplate</code>属性，或者直接注入一个<code>dataSource</code>属性（这两个属性来自于JdbcDaoSupport）：</p>

<pre><code>&lt;bean id="infoJdbcImpl" class="com.sohu.tv.dao.impl.InfoJdbcImpl"&gt;
    &lt;property name="dataSource" ref="feedbackDataSource"/&gt;
&lt;/bean&gt;
</code></pre>

<p>然后通过getJdbcTemplate()获取jdbcTemplate，实现dao层的逻辑：</p>

<pre><code>String getStudentByNumber = "select * from students where number = ?";
Map&lt;String, Object&gt; studentMap = getJdbcTemplate().queryForMap(getStudentByNumber, 111);
</code></pre>

<blockquote><p><code>NamedParameterJdbcDaoSupport</code>与<code>JdbcDaoSupport</code>的用法类似。</p></blockquote>

<h4>参考资料</h4>

<ul>
<li><a href="http://www.amazon.cn/Spring%E5%AE%9E%E6%88%98-%E6%B2%83%E5%B0%94%E6%96%AF/dp/B00CY6UD2I/ref=sr_1_1?ie=UTF8&amp;qid=1394943496&amp;sr=8-1&amp;keywords=spring+in+action">Spring实战(第3版)</a></li>
<li><a href="http://docs.spring.io/spring/docs/3.2.8.RELEASE/javadoc-api/">spring-javadoc-api</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring AOP之入门实例]]></title>
    <link href="http://nkcoder.github.io/blog/20140313/spring-aop-example/"/>
    <updated>2014-03-13T22:58:06+08:00</updated>
    <id>http://nkcoder.github.io/blog/20140313/spring-aop-example</id>
    <content type="html"><![CDATA[<p>依赖注入（DI）有助于应用对象之间的解耦，而面向切面编程（AOP）有助于横切关注点与所影响的对象之间的解耦。所谓横切关注点，即影响应用多处的功能，这些功能各个应用模块都需要，但又不是其主要关注点，常见的横切关注点有日志、事务和安全等。</p>

<p>将横切关注点抽离形成独立的类，即形成了切面。切面主要由切点和通知构成，通知定义了切面是什么，以及何时执行何种操作；切点定义了在何处执行通知定义的操作。</p>

<p>下面以简单的日志作为切面，分别介绍通过xml配置和注解实现AOP。</p>

<h3>0. 添加依赖</h3>

<p>因为Spring AOP用到AspectJ的相关对象和注解，需要添加AspectJ的依赖：</p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;
    &lt;version&gt;1.7.4&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
    &lt;version&gt;1.7.4&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;
    &lt;version&gt;${spring.version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<h3>1. 通过XML配置实现</h3>

<p>1.1 将日志类作为切面，定义为bean即可：</p>

<pre><code>@Service("logService")
public class LogService {
    private Logger logger = LoggerFactory.getLogger(LogService.class);

    public void printLog(ProceedingJoinPoint joinPoint) throws Throwable{
        logger.info("before service is called...");

        String methodModifier = joinPoint.getSignature().getDeclaringTypeName();
        String methodName = joinPoint.getSignature().getName();
        Object[] argsArr = joinPoint.getArgs();
        logger.info("class: {}; method: {}; args: {}", methodModifier, methodName, Arrays.toString(argsArr));
        joinPoint.proceed();

        logger.info("after service is called....");
    }
}
</code></pre>

<blockquote><p>首先，通过@Service注解将类定义为bean；方法printLog的参数<code>ProceedingJoinPoint</code>对象属于<code>AspectJ</code>，通过这个对象可以获取被通知的对象和方法的信息，并通过<code>proceed</code>方法执行被通知的对象。</p></blockquote>

<p>1.2 在xml配置文件里定义切面和切点</p>

<pre><code>&lt;aop:config&gt;
    &lt;aop:aspect ref="logService"&gt;
        &lt;aop:pointcut id="serviceLog" expression="execution(* org.yousharp.service.VideoService..*(..))"/&gt;
        &lt;aop:around method="printLog" pointcut-ref="serviceLog"/&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre>

<blockquote><p><code>aop:aspect</code>通过ref引用<code>logService</code> bean，将<code>LogService</code>定义为切面。<code>aop:pointcut</code>定义一个切点，被通知的对象通过<code>execution</code>表达式指定，即当<code>VideoService</code>下的任意方法被执行时，触发切面。<code>aop:aroud</code>定义一个环绕通知，引用切点*serviceLog<code>，当切面被触发时，调用</code>method`指定的方法。</p></blockquote>

<h3>2. 通过注解实现</h3>

<p>通过注解，可以直接在类上定义切面、通知和切点，无需任何xml配置。</p>

<pre><code>@Service("logService")
@Aspect
public class LogService {
    private Logger logger = LoggerFactory.getLogger(LogService.class);

    @Pointcut(value = "execution(* org.yousharp.service.VideoService.saveVideoInfo(..))")
    public void saveVideo() { }

    @Around(value = "saveVideo()")
    public void printLog(ProceedingJoinPoint joinPoint) throws Throwable{
        logger.info("before service is called...");
        String methodModifier = joinPoint.getSignature().getDeclaringTypeName();
        String methodName = joinPoint.getSignature().getName();
        Object[] argsArr = joinPoint.getArgs();
        logger.info("class: {}; method: {}; args: {}", methodModifier, methodName, Arrays.toString(argsArr));
        joinPoint.proceed();

        logger.info("after service is called....");
    }
}
</code></pre>

<blockquote><p><code>@Aspect</code>注解表示将该类定义为切面，<code>@Pointcut</code>定义切点，execution表达式与xml配置一样；切点的id即为空方法的方法名（这里的方法内容不重要，主要是供切点依附），这里即为saveVideo；<code>@Around</code>表示定义环绕通知，需要引用切点。</p></blockquote>

<h4>参考资料</h4>

<ul>
<li><a href="http://www.amazon.cn/Spring%E5%AE%9E%E6%88%98-%E6%B2%83%E5%B0%94%E6%96%AF/dp/B00CY6UD2I/ref=sr_1_1?ie=UTF8&amp;qid=1394943496&amp;sr=8-1&amp;keywords=spring+in+action">Spring实战(第3版)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring依赖注入之Java注解]]></title>
    <link href="http://nkcoder.github.io/blog/20140310/spring-di-java/"/>
    <updated>2014-03-10T23:29:44+08:00</updated>
    <id>http://nkcoder.github.io/blog/20140310/spring-di-java</id>
    <content type="html"><![CDATA[<blockquote><p>基于Java的注解，是在类级别上定义beans，在方法级别上定义bean。和自动注解一样，可以减少xml的配置。</p></blockquote>

<h3>1. xml配置</h3>

<p>在xml配置文件中添加自动扫描的配置：</p>

<pre><code>&lt;context:component-scan base-package="org.yousharp"/&gt;
</code></pre>

<blockquote><p>该配置不仅扫描构造型注解(@Controller, @Service, @Repository, @Component)，也会扫描@Configuration注解。</p></blockquote>

<h3>2. 定义dao类和service类</h3>

<p>dao类是service类的一个属性，是需要注入的对象。</p>

<pre><code>public class VideoService {
    SaveVideoInfoDao saveVideoInfoDao;

    public VideoService(){}

    public VideoService(SaveVideoInfoDao saveVideoInfoDao) {
        this.saveVideoInfoDao = saveVideoInfoDao;
    }

    public void saveVideoInfo(String info) {
        saveVideoInfoDao.printMesg(info);
    }
}

public class SaveVideoInfoDao {

    public void printMesg(String message) {
        System.out.println("saving video info....");
    }
}
</code></pre>

<blockquote><p>dao类和service类就是两个很普通的java类，没有任何注解依附。</p></blockquote>

<h3>3. 定义一个配置类</h3>

<p>单独定义一个配置类（在自动扫描包下），在类上使用@Configuration注解，在方法上使用@Bean注解：</p>

<pre><code>@Configuration
public class AppConfig {

    @Bean
    public SaveVideoInfoDao saveVideoInfoDao() {
        return new SaveVideoInfoDao();
    }

    @Bean
    public VideoService videoService() {
        VideoService videoService = new VideoService(saveVideoInfoDao());
        return videoService;
    }
}
</code></pre>

<blockquote><p>@Configuration注解等价于xml配置中的<code>beans</code>，该注解告诉Spring该类中包含一个或多个bean的定义；@Bean注解等价于xml配置中的<code>bean</code>，将方法返回的对象定义为bean，方法名为bean的id；上面第一个bean的定义等价于xml配置：</p></blockquote>

<pre><code>&lt;bean id="saveInfoDao" class="org.yousharp.AppConfig"/&gt;
</code></pre>

<p>第二个bean的定义通过构造函数实现依赖注入，其含义等价于xml配置：</p>

<pre><code>&lt;bean id="videoService" class="org.yousharp.AppConfig"&gt;
    &lt;constructor-arg name="videoService" ref="saveVideoInfoDao"&gt;
&lt;/bean&gt;
</code></pre>

<p>这里是通过构造函数实现注入，当然也可以通过setter方法实现注入。在VideoInfoService中去掉带参数的构造函数，同时对属性saveVideoInfoDao添加setter方法，修改AppConfig类中的第二个bean为：</p>

<pre><code>@Bean
public VideoService videoService() {
    VideoService videoService = new VideoService();
    videoService.setSaveVideoInfoDao(saveVideoInfoDao());
    return videoService;
}
</code></pre>

<h3>4. Controller中引用</h3>

<p>Controller里和使用xml配置bean和自动注解一样，通过bean的id获取对bean的引用。这里VideoService的bean的id为videoService。</p>

<pre><code>ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");

public void execute() {
    VideoService videoService = (VideoService) context.getBean("videoService");
    String videoInfo = "vrs video info";
    videoService.saveVideoInfo(videoInfo);
}
</code></pre>

<h4>参考资料</h4>

<ul>
<li><a href="http://www.amazon.cn/Spring%E5%AE%9E%E6%88%98-%E6%B2%83%E5%B0%94%E6%96%AF/dp/B00CY6UD2I/ref=sr_1_1?ie=UTF8&amp;qid=1394943496&amp;sr=8-1&amp;keywords=spring+in+action">Spring实战(第3版)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring依赖注入之注解注入]]></title>
    <link href="http://nkcoder.github.io/blog/20140309/spring-di-annotation/"/>
    <updated>2014-03-09T18:19:11+08:00</updated>
    <id>http://nkcoder.github.io/blog/20140309/spring-di-annotation</id>
    <content type="html"><![CDATA[<h3>1. bean的自动装配和自动检测的区别</h3>

<p>启用注解装配，在xml配置文件里添加：</p>

<pre><code>&lt;context:annotation-config/&gt;
</code></pre>

<p>启用自动扫描注解，在xml配置文件里添加：</p>

<pre><code>&lt;context:component-scan base-package="org.yousharp.base"/&gt;
</code></pre>

<blockquote><p>二者的区别：
自动装配表示通过@Autowired, @Inject, @Resource等实现对属性或构造函数的自动注入；仍然需要在配置文件里定义bean，只是通过自动装配省去了<code>property</code>和<code>constructor-arg</code>的配置。
自动检测是扫描特定的注解（包括：@Component, @Controller, @Service, @Repository)，将注解过的类自动定义为bean，自动检测是自动装配的超集，通过自动检测，可以省去在xml配置文件里定义<code>bean</code>了。</p></blockquote>

<h3>2. 通过自动装配和注解实现注入</h3>

<p>在xml配置文件里启动注解装配：</p>

<pre><code>&lt;context:annotation-config/&gt;
</code></pre>

<p>定义bean：</p>

<pre><code>&lt;bean id="saveVideoInfoDao" class="org.dao.SaveVideoInfoDao"/&gt;
</code></pre>

<p>然后在需要注入的属性上或者其setter方法上，或者构造函数上，添加@Autowired, @Inject, @Resource等注解实现自动注入：</p>

<pre><code>//@Autowired
//@Inject
@Resource
public void setSaveVideoInfoDao(SaveVideoInfoDao videoInfoDao) {
    this.saveVideoInfoDao = videoInfoDao;
}
</code></pre>

<blockquote><p>@Autowired, @Inject, @Resource的区别：@Autowired是Spring 3.0的注解，是通过byType形式实现注解，可以通过@Qualifier根据bean的id进行限定；使用@Autowired注解即引入了对Spring的依赖。@Inject是JSR 330的注解，使用该注解需要导入包javax.inject，@Named(value=&ldquo;&rdquo;)可以根据bean的id进行限定；@Resource是JSR 250的注解，可以通过value限定bean的id，如@Resource(value=&ldquo;&rdquo;);</p></blockquote>

<h3>3. 使用自动检测注解实现注入</h3>

<p>在xml配置文件里增加自动检测的配置：</p>

<pre><code>&lt;context:component-scan base-package="org.yousharp.base"/&gt;
</code></pre>

<p>将需要被自动检测而注册为bean的类使用对应的构造型注解：</p>

<pre><code>@Repository
public class SaveVideoInfoDao {

    public void printMesg(String message) {
        System.out.println("saving video info....");
    }
}
</code></pre>

<p>使用注解对依赖的属性进行输入：</p>

<pre><code>@Service
public class VideoService {
    @Resource
    SaveVideoInfoDao saveVideoInfoDao;

    public void saveVideoInfo(String info) {
        saveVideoInfoDao.printMesg(info);
    }
}
</code></pre>

<blockquote><p>@Component是通用的注解，@Controller表示将该类定义为Spring MVC的控制器，@Service定义服务层，@Repository定义数据仓库；这些构造型注解默认以无限定类名作为bean的id，也可以显式指定id名称，如@Service(&ldquo;videoInfoService&rdquo;)或者@Service(name=&ldquo;videoInfoService&rdquo;);</p></blockquote>

<h3>4. 自动检测注解的过滤</h3>

<p>可以为扫描行为定义过滤器，如<code>context:include-filter</code>, <code>context:exclude-filter</code></p>

<pre><code>&lt;context:component-scan base-package="org.yousharp"&gt;
    &lt;context:include-filter type="assignable" expression="org.yousharp.dao.SaveVideoInfoDao"/&gt;
    &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Component"/&gt;
&lt;/context:component-scan&gt;
</code></pre>

<blockquote><p><code>context:include-filter</code>表示需要扫描并注解的类，<code>context:exclude-filter</code>表示扫描时需要排除的包；<code>type</code>一种有5中，<code>assignable</code>表示继承自<code>expression</code>所指定的包，<code>annotation</code>表示所有expression所指定的注解。</p></blockquote>

<h4>参考资料</h4>

<ul>
<li><a href="http://www.amazon.cn/Spring%E5%AE%9E%E6%88%98-%E6%B2%83%E5%B0%94%E6%96%AF/dp/B00CY6UD2I/ref=sr_1_1?ie=UTF8&amp;qid=1394943496&amp;sr=8-1&amp;keywords=spring+in+action">Spring实战(第3版)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring依赖注入之XML配置]]></title>
    <link href="http://nkcoder.github.io/blog/20140308/spring-di-xml/"/>
    <updated>2014-03-08T21:36:47+08:00</updated>
    <id>http://nkcoder.github.io/blog/20140308/spring-di-xml</id>
    <content type="html"><![CDATA[<blockquote><p>因为项目中一直要用到Spring相关的知识，所以最近在看<a href="http://www.amazon.cn/Spring%E5%AE%9E%E6%88%98-%E6%B2%83%E5%B0%94%E6%96%AF/dp/B00CY6UD2I/ref=sr_1_1?ie=UTF8&amp;qid=1394286577&amp;sr=8-1&amp;keywords=spring%E5%AE%9E%E6%88%98">Spring实战</a>这本书，希望对Spring有一个整理的了解和把握。不得不说，这是一本好书，中文译本也不错。这个系列，记录自己关于Spring的笔记和理解，一是加深理解，同时也希望对别人有所帮助。</p></blockquote>

<h3>1. 通过构造方法和xml配置注入</h3>

<blockquote><p>定义带参数的构造函数，使依赖对象作为构造函数的参数：</p></blockquote>

<pre><code>public class VideoInfoServiceImpl implements VideoInfoService {
    VideoInfoDao videoInfoDao;

    public VideoInfoServiceImpl() {}

    public VideoInfoServiceImpl(VideoInfoDao videoInfoDao) {
        this.videoInfoDao = videoInfoDao;
    }

    @Override
    public List&lt;Map&lt;String, Object&gt;&gt; getVideos(Map&lt;String, Object&gt; queryMap) {
        List&lt;Map&lt;String, Object&gt;&gt; videoList = videoInfoDao.getVideos(queryMap);
        return videoList;
    }
}
</code></pre>

<blockquote><p>在定义bean时，使用<code>constructor-arg</code>标签，name表示构造函数的参数，ref表示引用另一个bean；参数也可以为基本类型，此时使用value标签，而不是ref。(如果不使用<code>constructor-arg</code>，则bean实例化时调用的是默认的不带参数的构造函数)</p></blockquote>

<pre><code>&lt;bean id="videoInfoServiceImpl" class="com.sohu.tv.service.impl.VideoInfoServiceImpl"&gt;
    &lt;constructor-arg name="videoInfoDao" ref="videoInfoDaoImpl"/&gt;
&lt;/bean&gt;

&lt;bean id="videoInfoServiceImpl" class="com.sohu.tv.service.impl.VideoInfoServiceImpl"&gt;
    &lt;constructor-arg name="id" value="25"/&gt;
&lt;/bean&gt;
</code></pre>

<h3>2. 通过setter方法和xml配置注入</h3>

<blockquote><p>定义依赖对象的setter方法，在bean定义时，使用<code>property</code>标签表示调用指定属性的setter方法，实现注入：</p></blockquote>

<pre><code>public class VideoInfoServiceImpl implements VideoInfoService {
    VideoInfoDao videoInfoDao;

    @Override
    public List&lt;Map&lt;String, Object&gt;&gt; getVideos(Map&lt;String, Object&gt; queryMap) {
        List&lt;Map&lt;String, Object&gt;&gt; videoList = videoInfoDao.getVideos(queryMap);
        return videoList;
    }

    public void setVideoInfoDao(VideoInfoDao videoInfoDao) {
        this.videoInfoDao = videoInfoDao;
    }
}
</code></pre>

<blockquote><p>property指定属性为videoInfoDao，则bean实例化后调用setVideoInfoDao方法实现注入；ref表示引用另一个bean，value表示基本类型值，int, float, true等。</p></blockquote>

<pre><code>&lt;bean id="videoInfoServiceImpl" class="com.sohu.tv.service.impl.VideoInfoServiceImpl"&gt;
    &lt;property name="videoInfoDao" ref="videoInfoDaoImpl"/&gt;
&lt;/bean&gt;
</code></pre>

<blockquote><p>此时也可以通过<code>bean</code>的p属性实现注入，比较简洁，需要加入p命令空间，和<code>property</code>方式是等价的。</p></blockquote>

<pre><code>xmlns:p="http://www.springframework.org/schema/p"

&lt;bean id="videoInfoServiceImpl" class="com.sohu.tv.service.impl.VideoInfoServiceImpl"
        p:videoInfoDao-ref="videoInfoDaoImpl" /&gt;
</code></pre>

<h3>3. 通过SpEL表达式注入</h3>

<blockquote><p>SpEL可以实现在运行时装配。SpEL通过#{}获取变量的值，{}中既可以是值类型，也可以是引用类型，通过bean的id引用其它的bean，此时，在SpEL中通过value引用其它的bean和通过ref直接引用bean的效果是相同的。</p></blockquote>

<pre><code>&lt;bean id="videoInfoServiceImpl" class="com.sohu.tv.service.impl.VideoInfoServiceImpl"&gt;
    &lt;!--&lt;property name="videoInfoDao" ref="videoInfoDaoImpl"/&gt;--&gt;
    &lt;property name="videoInfoDao" value="#{videoInfoDaoImpl}" /&gt;
&lt;/bean&gt;
</code></pre>

<h3>4. 通过setter方法和autowire=&ldquo;byName&#8221;自动装配注入</h3>

<blockquote><p>根据bean的名字进行注入，使用autowire=&ldquo;byName&#8221;，则寻找与属性名字相同的bean，通过属性的setter方法注入。</p></blockquote>

<pre><code>&lt;bean id="saveVideoInfoDao" class="org.dao.SaveVideoInfoDao"/&gt;
&lt;bean id="videoService" class="org.service.VideoService" autowire="byName"/&gt;
</code></pre>

<h3>5. 通过setter方法和autowire=&ldquo;byType&#8221;自动装配注入</h3>

<blockquote><p>根据bean的类型进行注入，使用autowire=&ldquo;byType&#8221;，则寻找与属性名字相同的bean，通过属性的setter方法注入：</p></blockquote>

<pre><code>&lt;bean id="saveVideoInfoDao" class="org.dao.SaveVideoInfoDao"/&gt;
&lt;bean id="videoService" class="org.service.VideoService" autowire="byType"/&gt;
</code></pre>

<h3>6. 通过factory-method给单例类定义bean</h3>

<blockquote><p>如果类的构造函数不可用，比如单例类，构造函数私有，通过public的接口获取实例；定义单例类的bean时，使用<code>factory-method</code>，表示调用类的静态方法构造实例：</p></blockquote>

<pre><code>&lt;bean id="singleton" class="yousharp.Singleton" factory-method="getInstance"/&gt;
&lt;bean id="factoryService" class="yousharp.FactoryService"&gt;
    &lt;constructor-arg name="singleton" ref="singleton"/&gt;
&lt;/bean&gt;
</code></pre>

<h3>7. 定义bean的作用域</h3>

<blockquote><p>默认是singleton，可以设置scope属性为prototype，表示每次调用都创建一个新实例：</p></blockquote>

<pre><code>&lt;bean id="videoInfoServiceImpl" class="com.sohu.tv.service.impl.VideoInfoServiceImpl"
    scope="prototype"/&gt;
</code></pre>

<h3>8. 装配list</h3>

<blockquote><p>数组或Collection的任意实现如List, ArrayList等都可以使用list和set来装配，区别在于set中不允许有重复元素。定义list成员的setter方法：</p></blockquote>

<pre><code>private List&lt;VideoInfoDao&gt; videoInfoDaoList;

public void setVideoInfoDaoList(List&lt;VideoInfoDao&gt; videoInfoDaoList) {
    this.videoInfoDaoList = videoInfoDaoList;
}
</code></pre>

<blockquote><p>在xml配置文件里，在<code>property</code>里定义<code>list</code>，给list成员注入实例：</p></blockquote>

<pre><code>&lt;bean id="videoInfoServiceImpl" class="com.sohu.tv.service.impl.VideoInfoServiceImpl"&gt;
    &lt;property name="videoInfoDaoList"&gt;
        &lt;list&gt;
            &lt;ref bean="jdbcDaoImple"/&gt;
            &lt;ref bean="mybatisDaoImpl"/&gt;
            &lt;ref bean="hibernateDaoImpl"/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>

<h3>9. 装配map</h3>

<blockquote><p>如果需要对一个map成员变量进行注入，在<code>property</code>里，通过<code>map</code>来实现注入，其中key和value都可以是值类型或引用类型；</p></blockquote>

<pre><code>private Map&lt;String, VideoInfoDaoImpl&gt; videoInfoDaoMap ;

public void setVideoInfoDaoList(Map&lt;String, VideoInfoDaoImpl&gt; videoInfoDaoMap) {
    this.videoInfoDaoMap = videoInfoDaoMap;
}

&lt;bean id="videoInfoServiceImpl" class="com.sohu.tv.service.impl.VideoInfoServiceImpl"&gt;
    &lt;property name="videoInfoDaoList"&gt;
        &lt;map&gt;
            &lt;entry key="jdbc" value-ref="videoInfoDaoImpl"/&gt;
            &lt;entry key="mybatis" value-ref="videoInfoDaoImpl"/&gt;
            &lt;entry key="hibernate" value-ref="videoInfoDaoImpl"/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>

<h3>10. 装配property</h3>

<blockquote><p>property也是key-value对，与map的区别是，其key和value必须都是String类型。</p></blockquote>

<pre><code>Properties props;
public void setProps(Properties props) {
    this.props = props;
}

&lt;bean id="videoInfoServiceImpl" class="com.sohu.tv.service.impl.VideoInfoServiceImpl" &gt;
    &lt;property name="props"&gt;
        &lt;props&gt;
            &lt;prop key="daily"&gt;30 00 * * *&lt;/prop&gt;
            &lt;prop key="weekly"&gt;30 00 * * 1&lt;/prop&gt;
            &lt;prop key="monthly"&gt;30 00 * 1 *&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>

<h4>参考资料</h4>

<ul>
<li><a href="http://www.amazon.cn/Spring%E5%AE%9E%E6%88%98-%E6%B2%83%E5%B0%94%E6%96%AF/dp/B00CY6UD2I/ref=sr_1_1?ie=UTF8&amp;qid=1394943496&amp;sr=8-1&amp;keywords=spring+in+action">Spring实战(第3版)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分布式搜索引擎ElasticSearch安装与配置]]></title>
    <link href="http://nkcoder.github.io/blog/20140217/elasticsearch-install-config/"/>
    <updated>2014-02-17T22:49:20+08:00</updated>
    <id>http://nkcoder.github.io/blog/20140217/elasticsearch-install-config</id>
    <content type="html"><![CDATA[<h3>1. 安装与启动</h3>

<h4>1.1 安装ElasticSearch</h4>

<blockquote><p>两种安装方式，一种是根据发行版，通过ElasticSearch提供的repositories安装，参考<a href="http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/setup-repositories.html">官方指南</a>; 另一种是利用压缩包安装；由于第二种方式，在配置上更加灵活，这里主要介绍第二种方式的安装和配置。</p></blockquote>

<p>从<a href="http://www.elasticsearch.org/overview/elkdownloads/">ElasticSearch网站</a>下载压缩包：<code>elasticsearch-1.0.0.tar.gz</code>，解压到指定目录：</p>

<pre><code>$ wget https://download.elasticsearch.org/elasticsearch/elasticsearch/elasticsearch-1.0.0.tar.gz -P /opt/app
$ cd /opt/app
$ tar zxvf elasticsearch-1.0.0.tar.gz -C ./
</code></pre>

<blockquote><p>启动ElasticSearch很简单，执行安装目录下bin/elasticsearch即可；ElasticSearch 1.0.0的启动机制有一些变化，默认在前台运行，-d参数表示在后台运行；另外还提供-p参数，后接文件名，保存当前ElasticSearch进程的pid，方便关闭进程；</p></blockquote>

<pre><code>$ bin/elasticsearch -d -p /tmp/es.pid
$ kill `cat /tmp/es.pid`
</code></pre>

<blockquote><p>另外还有一种启动方式，通过serviceWrapper，可以更加方便地控制ElasticSearch的启动、关闭以及重启，在下一节<code>安装插件</code>中介绍。</p></blockquote>

<h4>1.2 安装插件</h4>

<p>ElasticSearch官方和社区提供了很多插件用于将集群和节点的状态可视化。推荐安装的插件有：elasticsearch-head， marvel，bigdesk，servicewrapper</p>

<pre><code>// elasticsearch-head的安装与访问
# bin/plugin --install mobz/elasticsearch-head
http://localhost:9200/_plugin/head/

// marvel的安装与访问
# bin/plugin -i elasticsearch/marvel/latest
http://localhost:9200/_plugin/marvel

// bigdesk的安装与访问（当前不支持ElasticSearch 1.0.0）
# bin/plugin --install lukas-vlcek/bigdesk
http://localhost:9200/_plugin/bigdesk/
</code></pre>

<blockquote><p>下面介绍servicewrapper的使用：从<a href="https://github.com/elasticsearch/elasticsearch-servicewrapper">该链接</a>下载，解压后将service文件夹放到ElasticSearch安装目录下的bin目录下。</p></blockquote>

<pre><code>$ wget https://github.com/elasticsearch/elasticsearch-servicewrapper/archive/master.zip -P /opt/app
$ cd /opt/app
$ unzip elasticsearch-servicewrapper-master -d ./
$ mv elasticsearch-servicewrapper-master/service elasticsearch-1.0.0/bin/
</code></pre>

<blockquote><p>配置: 编辑elasticsearch.conf文件，主要是配置前两行：ES_HOME及ES_HEAP_SIZE</p></blockquote>

<pre><code>$ vim bin/service/elasticsearch.conf
// set.default.ES_HOME=/data/app/elasticsearch-1.0.0
// set.default.ES_HEAP_SIZE=2048
</code></pre>

<blockquote><p>用法：bin/service/elasticsearch start | stop | restart | install | remove | console | condrestart | status</p></blockquote>

<pre><code>$ bin/service/elasticsearch start
</code></pre>

<h3>2. 配置</h3>

<blockquote><p>配置文件为{ES_HOME}/config目录下的elasticsearch.yml，主要对集群、节点、索引（分片和副本）以及持久化和集群发现机制等进行参数设置。这里对一些常见的配置进行简单的说明和示例，配置文件的详细解释和说明会单独写一篇文章。</p></blockquote>

<pre><code>// 集群的名称，用于集群内节点的自动发现
cluster.name: es-test

// 节点的名称，标识一个节点
node.name: node_79_75

// 可以被选为主节点，同时可以存储数据
node.master: true
node.data: true

//节点的分片和副本的数量
index.number_of_shards: 3
index.number_of_replicas: 1

// 配置文件、索引数据以及日志和插件等的目录，如果不存在，新建即可
path.conf: /data/app/elasticsearch-1.0.0/config
path.data: /data/app/elasticsearch-1.0.0/data
path.logs: /data/app/elasticsearch-1.0.0/logs
path.plugins: /data/app/elasticsearch-1.0.0/plugins

// 锁定内存，防止内存交换影响ES性能
bootstrap.mlockall: true

// 持久化策略，本次存储
gateway.type: local

// 启用单播，显式指定节点的发现，当节点不在同一网段，无法自动发现时，启动单播，指定要发现的节点列表
// 比如当前节点的ip为10.10.79.75，与另两个节点不在同一网段，使用单播机制
discovery.zen.ping.multicast.enabled: false
discovery.zen.ping.unicast.hosts: ["10.11.52.131:9300", "10.11.52.134:9300"]
</code></pre>

<h4>参考</h4>

<ul>
<li><a href="http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/index.html">ElasticSearch reference</a></li>
<li><a href="http://www.searchtech.pro/articles/2013/02/18/1361194291548.html">ElasticSearch配置文件详解</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[xmemcached主要用法及与Spring集成]]></title>
    <link href="http://nkcoder.github.io/blog/20140216/xmemcached-usage-with-spring/"/>
    <updated>2014-02-16T21:35:36+08:00</updated>
    <id>http://nkcoder.github.io/blog/20140216/xmemcached-usage-with-spring</id>
    <content type="html"><![CDATA[<p>xMemcached是memcached的一个java客户端，基于java nio，支持memcached的所有协议。本文简要介绍xMemcached的基本用法，以及与Spring的集成配置。</p>

<h3>xMemcached的主要方法示例</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * XMemcachedClientBuilder是MemcachedClientBuilder的一个实现类，XMemcachedClient是MemcachedClient的一个实现类；</span>
</span><span class='line'><span class="cm"> * 在实际使用中，应该使用接口，利用多态特性，这里直接使用实现类，是为了方便查看实现类的源码。</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * MemcachedClientBuilder builder = new XMemcachedClientBuilder(AddrUtil.getAddresses(&quot;192.168.56.200:11211&quot;));</span>
</span><span class='line'><span class="cm"> * MemcachedClient memcachedClient = null;</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'>
</span><span class='line'><span class="n">XMemcachedClientBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">XMemcachedClientBuilder</span><span class="o">(</span><span class="n">AddrUtil</span><span class="o">.</span><span class="na">getAddresses</span><span class="o">(</span><span class="s">&quot;192.168.56.200:11211 192.168.56.200:11212&quot;</span><span class="o">));</span>
</span><span class='line'><span class="n">XMemcachedClient</span> <span class="n">xMemcachedClient</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 注意处理相关异常</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 默认是采用余数哈希，可以修改为一致性哈希</span>
</span><span class='line'><span class="n">builder</span><span class="o">.</span><span class="na">setSessionLocator</span><span class="o">(</span><span class="k">new</span> <span class="n">KetamaMemcachedSessionLocator</span><span class="o">());</span>
</span><span class='line'><span class="c1">// 启用二进制协议，getAndTouch等方法仅在二进制协议中支持</span>
</span><span class='line'><span class="n">builder</span><span class="o">.</span><span class="na">setCommandFactory</span><span class="o">(</span><span class="k">new</span> <span class="n">BinaryCommandFactory</span><span class="o">());</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// build the memcached client</span>
</span><span class='line'><span class="n">xMemcachedClient</span> <span class="o">=</span> <span class="o">(</span><span class="n">XMemcachedClient</span><span class="o">)</span> <span class="n">builder</span><span class="o">.</span><span class="na">build</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// set: 第一个参数是key，第二个参数是超时时间，第三个参数是value</span>
</span><span class='line'><span class="n">xMemcachedClient</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="s">&quot;first&quot;</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="s">&quot;tianjin&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">xMemcachedClient</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;second&quot;</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="s">&quot;chengdu&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">xMemcachedClient</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">&quot;first&quot;</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="s">&quot;Beijing&quot;</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// get：根据key获取value，第一个参数为key，第二个为超时；</span>
</span><span class='line'><span class="n">String</span> <span class="n">firstValue</span> <span class="o">=</span> <span class="n">xMemcachedClient</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&quot;first&quot;</span><span class="o">,</span> <span class="k">new</span> <span class="n">StringTranscoder</span><span class="o">());</span>
</span><span class='line'><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;get first value: {}&quot;</span><span class="o">,</span> <span class="n">xMemcachedClient</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&quot;first&quot;</span><span class="o">));</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// delete: 删除item</span>
</span><span class='line'><span class="n">xMemcachedClient</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="s">&quot;second&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">xMemcachedClient</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="s">&quot;third&quot;</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="s">&quot;xian&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">xMemcachedClient</span><span class="o">.</span><span class="na">deleteWithNoReply</span><span class="o">(</span><span class="s">&quot;third&quot;</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// touch：修改item过期时间</span>
</span><span class='line'><span class="n">xMemcachedClient</span><span class="o">.</span><span class="na">touch</span><span class="o">(</span><span class="s">&quot;first&quot;</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
</span><span class='line'><span class="n">firstValue</span> <span class="o">=</span> <span class="n">xMemcachedClient</span><span class="o">.</span><span class="na">getAndTouch</span><span class="o">(</span><span class="s">&quot;first&quot;</span><span class="o">,</span> <span class="mi">10</span><span class="o">);</span>
</span><span class='line'><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;getAndTouch op, first value: {}&quot;</span><span class="o">,</span> <span class="n">firstValue</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// append, prepend: 追加数据</span>
</span><span class='line'><span class="n">xMemcachedClient</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">&quot;first&quot;</span><span class="o">,</span> <span class="s">&quot;, come on&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">xMemcachedClient</span><span class="o">.</span><span class="na">prepend</span><span class="o">(</span><span class="s">&quot;first&quot;</span><span class="o">,</span> <span class="s">&quot;hello &quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;append and prepend op, first value: {}&quot;</span><span class="o">,</span> <span class="n">xMemcachedClient</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&quot;first&quot;</span><span class="o">));</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * cas: 通过gets操作返回GetResponse，其中包括value值和cas值</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="n">GetsResponse</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">response</span> <span class="o">=</span> <span class="n">xMemcachedClient</span><span class="o">.</span><span class="na">gets</span><span class="o">(</span><span class="s">&quot;first&quot;</span><span class="o">);</span>
</span><span class='line'><span class="kt">long</span> <span class="n">cas</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="na">getCas</span><span class="o">();</span>
</span><span class='line'><span class="k">if</span> <span class="o">(!</span><span class="n">xMemcachedClient</span><span class="o">.</span><span class="na">cas</span><span class="o">(</span><span class="s">&quot;first&quot;</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="s">&quot;guangzhou&quot;</span><span class="o">,</span> <span class="n">cas</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;cas error&quot;</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// cas: 重试更方便；第一个方法表示重试次数，第二个方法表示更新的值</span>
</span><span class='line'><span class="n">xMemcachedClient</span><span class="o">.</span><span class="na">cas</span><span class="o">(</span><span class="s">&quot;first&quot;</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="k">new</span> <span class="n">CASOperation</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>
</span><span class='line'>  <span class="nd">@Override</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getMaxTries</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nd">@Override</span>
</span><span class='line'>  <span class="kd">public</span> <span class="n">String</span> <span class="nf">getNewValue</span><span class="o">(</span><span class="kt">long</span> <span class="n">currentCAS</span><span class="o">,</span> <span class="n">String</span> <span class="n">currentValue</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="s">&quot;xian&quot;</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">});</span>
</span><span class='line'><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;cas op, first value: {}&quot;</span><span class="o">,</span> <span class="n">xMemcachedClient</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&quot;first&quot;</span><span class="o">));</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// incr/decr: 值的增加减少</span>
</span><span class='line'><span class="n">xMemcachedClient</span><span class="o">.</span><span class="na">incr</span><span class="o">(</span><span class="s">&quot;id&quot;</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
</span><span class='line'><span class="n">xMemcachedClient</span><span class="o">.</span><span class="na">incr</span><span class="o">(</span><span class="s">&quot;id&quot;</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
</span><span class='line'><span class="n">xMemcachedClient</span><span class="o">.</span><span class="na">decr</span><span class="o">(</span><span class="s">&quot;id&quot;</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
</span><span class='line'><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;incr/decr op, value: {}&quot;</span><span class="o">,</span> <span class="n">xMemcachedClient</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&quot;id&quot;</span><span class="o">));</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// namespace: set时指定命名空间，get时也需要指定，可以使命名空间中的所有items失效</span>
</span><span class='line'><span class="n">String</span> <span class="n">nsSohu</span> <span class="o">=</span> <span class="s">&quot;sohu&quot;</span><span class="o">;</span>
</span><span class='line'><span class="n">xMemcachedClient</span><span class="o">.</span><span class="na">withNamespace</span><span class="o">(</span><span class="n">nsSohu</span><span class="o">,</span> <span class="k">new</span> <span class="n">MemcachedClientCallable</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;()</span> <span class="o">{</span>
</span><span class='line'>  <span class="nd">@Override</span>
</span><span class='line'>  <span class="kd">public</span> <span class="n">Object</span> <span class="nf">call</span><span class="o">(</span><span class="n">MemcachedClient</span> <span class="n">client</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">MemcachedException</span><span class="o">,</span> <span class="n">InterruptedException</span><span class="o">,</span> <span class="n">TimeoutException</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">client</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="s">&quot;typeTv&quot;</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="s">&quot;tv&quot;</span><span class="o">);</span>
</span><span class='line'>      <span class="n">client</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="s">&quot;typeMv&quot;</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="s">&quot;mv&quot;</span><span class="o">);</span>
</span><span class='line'>      <span class="n">client</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="s">&quot;typeDrama&quot;</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="s">&quot;drama&quot;</span><span class="o">);</span>
</span><span class='line'>      <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">});</span>
</span><span class='line'>
</span><span class='line'><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;namespace op, typeTv: {}&quot;</span><span class="o">,</span> <span class="n">xMemcachedClient</span><span class="o">.</span><span class="na">withNamespace</span><span class="o">(</span><span class="n">nsSohu</span><span class="o">,</span> <span class="k">new</span> <span class="n">MemcachedClientCallable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>
</span><span class='line'>  <span class="nd">@Override</span>
</span><span class='line'>  <span class="kd">public</span> <span class="n">String</span> <span class="nf">call</span><span class="o">(</span><span class="n">MemcachedClient</span> <span class="n">client</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">MemcachedException</span><span class="o">,</span> <span class="n">InterruptedException</span><span class="o">,</span> <span class="n">TimeoutException</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">client</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&quot;typeTv&quot;</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}));</span>
</span><span class='line'><span class="n">xMemcachedClient</span><span class="o">.</span><span class="na">invalidateNamespace</span><span class="o">(</span><span class="n">nsSohu</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// stats: 获取统计，也可以根据items获取统计</span>
</span><span class='line'><span class="n">Map</span><span class="o">&lt;</span><span class="n">InetSocketAddress</span><span class="o">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">stats</span> <span class="o">=</span> <span class="n">xMemcachedClient</span><span class="o">.</span><span class="na">getStats</span><span class="o">();</span>
</span><span class='line'><span class="k">for</span> <span class="o">(</span><span class="n">InetSocketAddress</span> <span class="nl">addr:</span> <span class="n">stats</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;stats map: {}: {}&quot;</span><span class="o">,</span> <span class="n">addr</span><span class="o">,</span> <span class="n">stats</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">addr</span><span class="o">).</span><span class="na">toString</span><span class="o">());</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// flush_all: 是所有item都过期</span>
</span><span class='line'><span class="n">xMemcachedClient</span><span class="o">.</span><span class="na">flushAll</span><span class="o">(</span><span class="s">&quot;192.168.56.200:11211&quot;</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 删除一个server</span>
</span><span class='line'><span class="n">xMemcachedClient</span><span class="o">.</span><span class="na">removeServer</span><span class="o">(</span><span class="s">&quot;192.168.56.200:11212&quot;</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<h3>xMemcached与Spring集成</h3>

<blockquote><p>applicationContext.xml的配置：</p></blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="o">&lt;!--</span><span class="err">定义一个</span><span class="n">server</span><span class="o">--&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">bean</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;server1&quot;</span> <span class="n">class</span><span class="o">=</span><span class="s">&quot;java.net.InetSocketAddress&quot;</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="o">&lt;</span><span class="n">constructor</span><span class="o">-</span><span class="n">arg</span><span class="o">&gt;&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="mf">192.168</span><span class="o">.</span><span class="mf">56.200</span><span class="o">&lt;/</span><span class="n">value</span><span class="o">&gt;&lt;/</span><span class="n">constructor</span><span class="o">-</span><span class="n">arg</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="o">&lt;</span><span class="n">constructor</span><span class="o">-</span><span class="n">arg</span><span class="o">&gt;&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="mi">11211</span><span class="o">&lt;/</span><span class="n">value</span><span class="o">&gt;&lt;/</span><span class="n">constructor</span><span class="o">-</span><span class="n">arg</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">bean</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;!--</span><span class="err">定义</span><span class="n">XMemcachedClientBuilder</span><span class="err">实例，第一个参数设置</span><span class="n">server</span><span class="err">，第二个参数设置权重</span><span class="o">--&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">bean</span> <span class="n">id</span><span class="o">=</span><span class="s">&quot;memcachedClientBuilder&quot;</span> <span class="n">class</span><span class="o">=</span><span class="s">&quot;net.rubyeye.xmemcached.XMemcachedClientBuilder&quot;</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="o">&lt;</span><span class="n">constructor</span><span class="o">-</span><span class="n">arg</span><span class="o">&gt;</span>
</span><span class='line'>        <span class="o">&lt;</span><span class="n">list</span><span class="o">&gt;</span>
</span><span class='line'>            <span class="o">&lt;</span><span class="n">bean</span> <span class="n">class</span><span class="o">=</span><span class="s">&quot;java.net.InetSocketAddress&quot;</span><span class="o">&gt;</span>
</span><span class='line'>                <span class="o">&lt;</span><span class="n">constructor</span><span class="o">-</span><span class="n">arg</span><span class="o">&gt;&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="mf">192.168</span><span class="o">.</span><span class="mf">56.200</span><span class="o">&lt;/</span><span class="n">value</span><span class="o">&gt;&lt;/</span><span class="n">constructor</span><span class="o">-</span><span class="n">arg</span><span class="o">&gt;</span>
</span><span class='line'>                <span class="o">&lt;</span><span class="n">constructor</span><span class="o">-</span><span class="n">arg</span><span class="o">&gt;&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="mi">11211</span><span class="o">&lt;/</span><span class="n">value</span><span class="o">&gt;&lt;/</span><span class="n">constructor</span><span class="o">-</span><span class="n">arg</span><span class="o">&gt;</span>
</span><span class='line'>            <span class="o">&lt;/</span><span class="n">bean</span><span class="o">&gt;</span>
</span><span class='line'>            <span class="o">&lt;</span><span class="n">bean</span> <span class="n">class</span><span class="o">=</span><span class="s">&quot;java.net.InetSocketAddress&quot;</span><span class="o">&gt;</span>
</span><span class='line'>                <span class="o">&lt;</span><span class="n">constructor</span><span class="o">-</span><span class="n">arg</span><span class="o">&gt;&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="mf">192.168</span><span class="o">.</span><span class="mf">56.200</span><span class="o">&lt;/</span><span class="n">value</span><span class="o">&gt;&lt;/</span><span class="n">constructor</span><span class="o">-</span><span class="n">arg</span><span class="o">&gt;</span>
</span><span class='line'>                <span class="o">&lt;</span><span class="n">constructor</span><span class="o">-</span><span class="n">arg</span><span class="o">&gt;&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="mi">11212</span><span class="o">&lt;/</span><span class="n">value</span><span class="o">&gt;&lt;/</span><span class="n">constructor</span><span class="o">-</span><span class="n">arg</span><span class="o">&gt;</span>
</span><span class='line'>            <span class="o">&lt;/</span><span class="n">bean</span><span class="o">&gt;</span>
</span><span class='line'>        <span class="o">&lt;/</span><span class="n">list</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="o">&lt;/</span><span class="n">constructor</span><span class="o">-</span><span class="n">arg</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="o">&lt;</span><span class="n">constructor</span><span class="o">-</span><span class="n">arg</span><span class="o">&gt;</span>
</span><span class='line'>        <span class="o">&lt;</span><span class="n">list</span><span class="o">&gt;</span>
</span><span class='line'>            <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="mi">1</span><span class="o">&lt;/</span><span class="n">value</span><span class="o">&gt;</span>
</span><span class='line'>            <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="mi">2</span><span class="o">&lt;/</span><span class="n">value</span><span class="o">&gt;</span>
</span><span class='line'>        <span class="o">&lt;/</span><span class="n">list</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="o">&lt;/</span><span class="n">constructor</span><span class="o">-</span><span class="n">arg</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">&lt;!--&amp;</span><span class="n">lt</span><span class="o">;!&amp;</span><span class="n">ndash</span><span class="o">;</span><span class="err">设置验证信息</span><span class="o">&amp;</span><span class="n">ndash</span><span class="o">;&amp;</span><span class="n">gt</span><span class="o">;--&gt;</span>
</span><span class='line'>    <span class="o">&lt;!--&lt;</span><span class="n">property</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;authInfoMap&quot;</span><span class="o">&gt;--&gt;</span>
</span><span class='line'>        <span class="o">&lt;!--&lt;</span><span class="n">map</span><span class="o">&gt;--&gt;</span>
</span><span class='line'>            <span class="o">&lt;!--&lt;</span><span class="n">entry</span> <span class="n">key</span><span class="o">-</span><span class="n">ref</span><span class="o">=</span><span class="s">&quot;server1&quot;</span><span class="o">&gt;--&gt;</span>
</span><span class='line'>                <span class="o">&lt;!--&lt;</span><span class="n">bean</span> <span class="n">class</span><span class="o">=</span><span class="s">&quot;net.rubyeye.xmemcached.auth.AuthInfo&quot;</span> <span class="n">factory</span><span class="o">-</span><span class="n">method</span><span class="o">=</span><span class="s">&quot;typical&quot;</span><span class="o">&gt;--&gt;</span>
</span><span class='line'>                    <span class="o">&lt;!--&lt;</span><span class="n">constructor</span><span class="o">-</span><span class="n">arg</span> <span class="n">index</span><span class="o">=</span><span class="s">&quot;0&quot;</span><span class="o">&gt;&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="n">index</span><span class="o">&lt;/</span><span class="n">value</span><span class="o">&gt;&lt;/</span><span class="n">constructor</span><span class="o">-</span><span class="n">arg</span><span class="o">&gt;--&gt;</span>
</span><span class='line'>                    <span class="o">&lt;!--&lt;</span><span class="n">constructor</span><span class="o">-</span><span class="n">arg</span> <span class="n">index</span><span class="o">=</span><span class="s">&quot;1&quot;</span><span class="o">&gt;&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="n">index</span><span class="o">-</span><span class="n">pd</span><span class="o">&lt;/</span><span class="n">value</span><span class="o">&gt;&lt;/</span><span class="n">constructor</span><span class="o">-</span><span class="n">arg</span><span class="o">&gt;--&gt;</span>
</span><span class='line'>                <span class="o">&lt;!--&lt;/</span><span class="n">bean</span><span class="o">&gt;--&gt;</span>
</span><span class='line'>            <span class="o">&lt;!--&lt;/</span><span class="n">entry</span><span class="o">&gt;--&gt;</span>
</span><span class='line'>        <span class="o">&lt;!--&lt;/</span><span class="n">map</span><span class="o">&gt;--&gt;</span>
</span><span class='line'>    <span class="o">&lt;!--&lt;/</span><span class="n">property</span><span class="o">&gt;--&gt;</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">&lt;!--</span><span class="err">设置线程池</span><span class="o">--&gt;</span>
</span><span class='line'>    <span class="o">&lt;</span><span class="n">property</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;connectionPoolSize&quot;</span> <span class="n">value</span><span class="o">=</span><span class="s">&quot;2&quot;</span><span class="o">&gt;&lt;/</span><span class="n">property</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">&lt;!--</span><span class="err">使用二进制协议</span><span class="o">--&gt;</span>
</span><span class='line'>    <span class="o">&lt;</span><span class="n">property</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;commandFactory&quot;</span><span class="o">&gt;</span>
</span><span class='line'>        <span class="o">&lt;</span><span class="n">bean</span> <span class="n">class</span><span class="o">=</span><span class="s">&quot;net.rubyeye.xmemcached.command.BinaryCommandFactory&quot;</span><span class="o">&gt;&lt;/</span><span class="n">bean</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="o">&lt;/</span><span class="n">property</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'>   <span class="o">&lt;!--</span><span class="err">设置序列化方式</span><span class="o">--&gt;</span>
</span><span class='line'>    <span class="o">&lt;</span><span class="n">property</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;transcoder&quot;</span><span class="o">&gt;</span>
</span><span class='line'>        <span class="o">&lt;</span><span class="n">bean</span> <span class="n">class</span><span class="o">=</span><span class="s">&quot;net.rubyeye.xmemcached.transcoders.SerializingTranscoder&quot;</span><span class="o">&gt;&lt;/</span><span class="n">bean</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="o">&lt;/</span><span class="n">property</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">&lt;!--</span><span class="err">设置一致性哈希</span><span class="o">--&gt;</span>
</span><span class='line'>    <span class="o">&lt;</span><span class="n">property</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;sessionLocator&quot;</span><span class="o">&gt;</span>
</span><span class='line'>        <span class="o">&lt;</span><span class="n">bean</span> <span class="n">class</span><span class="o">=</span><span class="s">&quot;net.rubyeye.xmemcached.impl.KetamaMemcachedSessionLocator&quot;</span><span class="o">&gt;&lt;/</span><span class="n">bean</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="o">&lt;/</span><span class="n">property</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;/</span><span class="n">bean</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;!--</span><span class="err">定义</span><span class="n">memcachedClient</span><span class="err">，通过</span><span class="n">memcachedClientBuilder</span><span class="err">的</span><span class="n">build</span><span class="err">方法</span><span class="o">--&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">bean</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;memcachedClient&quot;</span> <span class="n">factory</span><span class="o">-</span><span class="n">bean</span><span class="o">=</span><span class="s">&quot;memcachedClientBuilder&quot;</span>
</span><span class='line'>      <span class="n">factory</span><span class="o">-</span><span class="n">method</span><span class="o">=</span><span class="s">&quot;build&quot;</span> <span class="n">destroy</span><span class="o">-</span><span class="n">method</span><span class="o">=</span><span class="s">&quot;shutdown&quot;</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">bean</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote><p>java测试类：</p></blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">MemcachedClient</span> <span class="n">memcachedClient</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'><span class="n">ApplicationContext</span> <span class="n">applicationContext</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ClassPathXmlApplicationContext</span><span class="o">(</span><span class="s">&quot;applicationContext.xml&quot;</span><span class="o">);</span>
</span><span class='line'><span class="k">try</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">memcachedClient</span> <span class="o">=</span> <span class="o">(</span><span class="n">MemcachedClient</span><span class="o">)</span> <span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">&quot;memcachedClient&quot;</span><span class="o">);</span>
</span><span class='line'>  <span class="n">memcachedClient</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="s">&quot;spring&quot;</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="s">&quot;3.0.0.RELEASE&quot;</span><span class="o">);</span>
</span><span class='line'>  <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;spring: {}&quot;</span><span class="o">,</span> <span class="n">memcachedClient</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&quot;spring&quot;</span><span class="o">));</span>
</span><span class='line'>  <span class="n">memcachedClient</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">&quot;spring&quot;</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="s">&quot;4.0.0.RELEASE is coming&quot;</span><span class="o">);</span>
</span><span class='line'>  <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;spring, {}&quot;</span><span class="o">,</span> <span class="n">memcachedClient</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&quot;spring&quot;</span><span class="o">));</span>
</span><span class='line'><span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;spring test&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>参考</h4>

<ul>
<li><a href="https://code.google.com/p/xmemcached/wiki/User_Guide_zh">xmemcached user_guide_zh</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[memcached用法：参数和命令详解]]></title>
    <link href="http://nkcoder.github.io/blog/20140215/memcached-usage-parameters-commands/"/>
    <updated>2014-02-15T23:02:36+08:00</updated>
    <id>http://nkcoder.github.io/blog/20140215/memcached-usage-parameters-commands</id>
    <content type="html"><![CDATA[<h3>1. memcached 参数说明：</h3>

<pre><code># memcached -h
</code></pre>

<h4>1.1 memcached 的参数</h4>

<p>常用参数</p>

<pre><code>-p &lt;num&gt; 监听的TCP端口号，默认是11211；（port）
-l &lt;addr&gt; 监听的主机地址，默认是INADDR_ANY，即所有地址，&lt;addr&gt;可以是host:port的形式，如果没有指定port，则使用-p或者-U的值；可以指定多个地址，以逗号分隔或者多次使用-l参数；尽量不要使用默认值，有安全隐患。(listen)
-d 以守护进程运行 (daemon)
-u &lt;username&gt; 指定进程的所有者（只有以root用户执行时才可以使用该参数）(username)
-m &lt;num&gt; 用于存储数据的最大内存，单位是MB，默认是64MB；(memory)
-c &lt;num&gt; 最大并发连接数，默认是1024；
-vv 显示更详细的信息（还显示客户端的命令和响应）
-vvv 显示最详细的信息（还显示内部的状态转变）
-h 显示帮助信息
-P &lt;file&gt; 将PID保存到&lt;file&gt;中，仅和-d参数一起使用；
-f &lt;factor&gt; chunk的增幅因子，默认是1.25，不同的slab class，slab page大小相同，但是chunk大小不等，chunk的大小根据这个增幅因子增长；(factor)
-n &lt;bytes&gt; 为key+value+flags分配的最小内存，单位bytes，默认是48；chunk数据结构本身要占据48字节，所以实际大小是n+48；
-t &lt;num&gt; 使用多少个线程，默认是4；（thread）
-I 设置slab page的大小，即设置可以保存的item的最大值，默认1MB，最小是1K，最大值128M；
</code></pre>

<p>其它参数</p>

<pre><code>-U &lt;num&gt; 监听的UDP端口号，默认是11211，0表示关闭UDP监听；（UDP）
-s &lt;file&gt; 要监听的UNIX socket路径（禁用网络支持）（socket)
-a &lt;mask&gt; UNIX socket的访问掩码（access mask），八进制表示，默认是0700. (mask)
-r 文件数量的最大值 (rlimit)
-M 内存耗尽时返回错误，而不是通过LRU淘汰内容；
-k 锁定所有页内存；允许被锁定的内存是有限制的，超过限制可能会失败。
-v 显示启动信息（错误和警告信息）(verbose)
-i 显示memcached和libevent的licence信息
-L 一次申请大的内存页（如果可以）；增大内存页的大小，可以提高性能；
-D &lt;char&gt; 指定key前缀与ID的分隔符，用于stats信息显示，默认是冒号：，如果使用了该参数，则stats收集自动启用了，否则，需要发送命令“stats detail on”命令来启动stats的收集。
-R 每一个事件（event）的最大请求数，限制最大请求数可以防止线程饥饿，默认是20；
-C 禁用CAS；
-b 设置backlog队列限制，默认1024；
-B 指定绑定协议，ascii，binary或者auto，其中auto是默认值；
</code></pre>

<h4>1.2 repcached的参数：</h4>

<pre><code>-x &lt;ip_addr&gt; peer主机的主机名或者ip地址；
-X peer主机的TCP端口，即主从同步端口，共同的监听端口
</code></pre>

<h4>1.3 常用的参数组合</h4>

<pre><code># memcached -d -m -p 11212 -u nobody -l 127.0.0.1 -x 127.0.0.1 -X 11222 -P /tmp/localhost_slave.pid -vv
</code></pre>

<h3>2. 基本命令与操作</h3>

<h4>2.1 存储的命令</h4>

<p>主要有：set，add，replace，append，prepend，cas；格式为：</p>

<pre><code>command key flag expiration_time bytes
value
</code></pre>

<blockquote><p>key表示键，flag表示key/value的额外信息，expiration_time表示过期时间，单位为秒，0表示永不过期，bytes表示值所占的字节数，必须完全匹配，value表示key对应的值，总是出现在第二行。</p>

<p>set命令表示存储一个key/value对，如果该key已存在，则更新对应的value值；如果成功，返回STORED。</p></blockquote>

<pre><code>set file_path 0 0 5
/opt/
&lt;29 rep file_path 0 0 5 12
REP&gt;29 STORED
STORED
</code></pre>

<blockquote><p>add命令也表示增加key/value，如果key/value已存在，add操作失败；保存成功返回STORED，失败返回NOT_STORED。</p></blockquote>

<pre><code>add file_path 0 60 5
/opt/
NOT_STORED
add file_suffix 0 0 2
js
&lt;29 rep file_suffix 0 0 2 16
REP&gt;29 STORED
STORED
</code></pre>

<blockquote><p>replace命令表示更新key对应的value值，如果key/value不存在，replace操作失败；成功返回STORED，失败返回NOT_STORED；</p></blockquote>

<pre><code>replace first 0 0 7
tianjin
STORED
replace second 0 0 8
shanghai
NOT_STORED
</code></pre>

<blockquote><p>append表示在key对应的value值后追加数据，key必须已存在，否则操作失败；成功返回STORED，失败返回NOT_STORED；</p></blockquote>

<pre><code>append second 0 0 8
shanghai
NOT_STORED
append first 0 0 3
 go
STORED
</code></pre>

<blockquote><p>prepend在key对应的value值的前面追加数据，key必须已存在，否则操作失败；成功返回STORED，失败返回NOT_STORED；</p></blockquote>

<pre><code>prepend second 0 0 2
hi
NOT_STORED
prepend first 0 0 2
hi
STORED
get first
VALUE first 0 15
hitianjin go go
END
</code></pre>

<blockquote><p>cas (check and set)：先比较后存储，即原子更新，原理类似于乐观所。每次请求存储某个数据时附带一个cas值，memcached比对这个cas值与当前存储数据的cas值是否相等，如果相等，则更新数据，否则操作失败；当前存储的cas值通过gets命令获取。成功返回STORED，失败返回EXISTS。</p></blockquote>

<pre><code>gets first
VALUE first 0 7 12      // 12表示cas id，可以理解为版本号
chengdu
END
cas first 0 0 8 10      // 10 != 12，cas失败
shanghai
EXISTS
cas first 0 0 8 12      // 12表示gets后没有修改key的值，因此可以set
shanghai
STORED
</code></pre>

<h4>2.2 读取的命令</h4>

<blockquote><p>get根据key获取value值；可以获取多个key的值；get key | get key1 key2</p></blockquote>

<pre><code>get first
VALUE first 0 8
shanghai
END

get first fine
VALUE first 0 8
shanghai
VALUE fine 0 5
yes!!
END
</code></pre>

<blockquote><p>gets是与cas一起使用的命令，gets会额外返回一个cas值，可以理解为版本；如果最后一次gets后，该cas值改变了，则cas设置的值不会存储；gets key | gets key1 key2</p></blockquote>

<pre><code>gets first
VALUE first 0 8 13
shanghai
END
set first 0 0 7
chengdu
STORED
cas first 0 0 7 13      // 因为gets后set了，所以cas id改变了，cas失败
chengdu
EXISTS
</code></pre>

<blockquote><p>delete命令删除key/value对，一次只能删除一个key/value对；如果要删除的key不存在，操作失败: delete key</p></blockquote>

<pre><code>delete first second
CLIENT_ERROR bad command line format.  Usage: delete &lt;key&gt; [noreply]
delete first
DELETED
</code></pre>

<blockquote><p>incr/decr: 如果key的value值表示的是一个64位整数，可以通过incr和decr命令进行数值的增减: incr/decr key num</p></blockquote>

<pre><code>set id 0 120 2
10
STORED
incr id 10
20
decr id 5
15
</code></pre>

<h4>2.3 统计的命令</h4>

<blockquote><p>stats显示进程及当前状态等信息。</p></blockquote>

<pre><code>stats 
STAT pid 1224           // 进程id
STAT uptime 30385       // 系统运行的事件，单位：秒
STAT time 1392199633    // 系统当前事件，Unix时间戳表示的时间：2/12/2014 6:25:40 PM
STAT version 1.4.13         // memcached版本
STAT libevent 2.0.21-stable // libevent版本
STAT pointer_size 64        // 操作系统字大小（64位）
STAT rusage_user 1.892712   // 进程累计用户时间
STAT rusage_system 0.996848 // 进程累计系统时间
STAT curr_connections 8     // 当前打开的连接数
STAT total_connections 9    // 曾打开的连接总数
STAT connection_structures 9    // 服务器分配的连接结构数
STAT reserved_fds 20
STAT cmd_get 29             // 执行get命令的总数
STAT cmd_set 29             // 执行set命令的总数
STAT cmd_flush 2            // 执行flush_all命令的总数
STAT cmd_touch 0             
STAT get_hits 14            
STAT get_misses 15          
STAT delete_misses 3        
STAT delete_hits 3
STAT incr_misses 0
STAT incr_hits 4
STAT decr_misses 0
STAT decr_hits 2
STAT cas_misses 1
STAT cas_hits 2
STAT cas_badval 2
STAT touch_hits 0
STAT touch_misses 0
STAT auth_cmds 0
STAT auth_errors 0
STAT bytes_read 1503
STAT bytes_written 4125
STAT limit_maxbytes 134217728
STAT accepting_conns 1
STAT listen_disabled_num 0
STAT threads 4              // 线程数
STAT conn_yields 0
STAT hash_power_level 16
STAT hash_bytes 524288
STAT hash_is_expanding 0
STAT expired_unfetched 0
STAT evicted_unfetched 0
STAT replication MASTER
STAT repcached_version 2.3.1
STAT repcached_qi_free 8191
STAT bytes 217              // 存储的item字节数
STAT curr_items 3           // 当前item数量
STAT total_items 25         // item的总数
STAT evictions 0            // 为获取空间删除的item数量
STAT reclaimed 2
END
</code></pre>

<blockquote><p>stats items 显示items的相关信息</p></blockquote>

<pre><code>stats items
STAT items:1:number 3
STAT items:1:age 1552
STAT items:1:evicted 0
STAT items:1:evicted_nonzero 0
STAT items:1:evicted_time 0
STAT items:1:outofmemory 0
STAT items:1:tailrepairs 0
STAT items:1:reclaimed 2
STAT items:1:expired_unfetched 0
STAT items:1:evicted_unfetched 0
END
</code></pre>

<blockquote><p>stats slabs 显示slab的相关信息</p></blockquote>

<pre><code>stats slabs
STAT 1:chunk_size 96
STAT 1:chunks_per_page 10922
STAT 1:total_pages 1
STAT 1:total_chunks 10922
STAT 1:used_chunks 3
STAT 1:free_chunks 0
STAT 1:free_chunks_end 10919
STAT 1:mem_requested 217
STAT 1:get_hits 14
STAT 1:cmd_set 29
STAT 1:delete_hits 3
STAT 1:incr_hits 4
STAT 1:decr_hits 2
STAT 1:cas_hits 2
STAT 1:cas_badval 2
STAT 1:touch_hits 0
STAT active_slabs 1
STAT total_malloced 1048512
END
</code></pre>

<blockquote><p>stats sizes</p></blockquote>

<pre><code>stats sizes
STAT 96 3
END
</code></pre>

<blockquote><p>stats cachedump 显示slab中items的信息(该命令在将来可能不再支持）：stats cachedump [slab id] [number of items, 0 for all items]</p></blockquote>

<pre><code>set city 0 0 7
tianjin
STORED
stats cachedump 1 0
ITEM city [7 b; 1392169248 s]
END
get city
VALUE city 0 7
tianjin
END
</code></pre>

<blockquote><p>flush_all 使cache中的所有items都过期，server不会停止，也不会刷新或者释放内存。</p></blockquote>

<pre><code>flush_all
OK
get first
END
</code></pre>

<h4>参考</h4>

<ul>
<li><a href="https://code.google.com/p/memcached/wiki/NewStart">memcached wiki</a></li>
<li><a href="http://www.zrwm.com/?p=642">memcached命令行操作</a></li>
<li><a href="http://blog.csdn.net/wanghai__/article/details/8539435">memcached命令行参数说明</a></li>
<li><a href="http://freeloda.blog.51cto.com/2033581/1289806">memcached详解</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[memcached安装: libevent-repcached-memcached]]></title>
    <link href="http://nkcoder.github.io/blog/20140213/memcached-install-libevent-repcached-memcached/"/>
    <updated>2014-02-13T07:58:41+08:00</updated>
    <id>http://nkcoder.github.io/blog/20140213/memcached-install-libevent-repcached-memcached</id>
    <content type="html"><![CDATA[<blockquote><p>安装顺序：</p></blockquote>

<pre><code>1. 先安装libevent，因为memcached依赖它；
2. 给memcached打上repcached补丁，支持主从结构，实现高可用；
3. 安装memcached，启用replication；
</code></pre>

<h3>1. libevent</h3>

<pre><code># wget https://github.com/downloads/libevent/libevent/libevent-2.0.21-stable.tar.gz -P /opt/softs/
# ./configure --prefix=/usr/local/
# make &amp;&amp; make install
</code></pre>

<h3>2. repcached &amp;&amp; memcached</h3>

<p>当前补丁最新位1.4.13，memcached的版本应该一直，否则会出现异常；</p>

<pre><code># wget https://memcached.googlecode.com/files/memcached-1.4.13.tar.gz -P /opt/softs/
# wget http://mdounin.ru/files/repcached-2.3.1-1.4.13.patch.gz -P ./

# tar zxvf memcached-1.4.13.tar.gz -C /opt/softs/
# gzip -d repcached-2.3.1-1.4.13.patch.gz

# cd /opt/softs/memcached-1.4.13
# patch -p1 -i ../repcached-2.3.1-1.4.13.patch
# ./configure --prefix=/usr/local/ --with-libevent=/usr/local/ --enable-replication
# make &amp;&amp; make install
</code></pre>

<h3>3. memcached (with repcached) 主从测试</h3>

<p>在本机的两个不同的端口上启动两个memcached实例，一主一从，然后测试相互之间的数据同步。
memcached主从测试在本机的两个不同的端口上启动两个memcached实例，一主一从，然后测试相互之间的数据同步。</p>

<h4>3.1 启动两个memcached实例</h4>

<pre><code># memcached -d -m -p 11211 -u nobody -l 127.0.0.1 -x 127.0.0.1 -X 11222 -P /tmp/localhost_master.pid -vv
# memcached -d -m -p 11212 -u nobody -l 127.0.0.1 -x 127.0.0.1 -X 11222 -P /tmp/localhost_slave.pid -vv
</code></pre>

<blockquote><p>两个实例的端口分别为11211和11212，共同的监听端口为11222。</p></blockquote>

<h4>3.2 通过telnet测试数据的同步</h4>

<blockquote><p>进入master，set两个值</p></blockquote>

<pre><code>[root@localhost ~]# telnet 127.0.0.1 11211
Trying 127.0.0.1...
&lt;31 new auto-negotiating client connection
Connected to 127.0.0.1.
Escape character is '^]'.
set city 0 0 7
31: Client using the ascii protocol
&lt;31 set city 0 0 7
tianjin
&gt;31 STORED
replication: pop
replication: pop
STORED
set city2 0 0 7
&lt;31 set city2 0 0 7
beijing
&gt;31 STORED
replication: pop
replication: pop
STORED  
</code></pre>

<blockquote><p>进入slave，get刚才设置的值，并删除其中一个值</p></blockquote>

<pre><code>[root@localhost ~]# telnet 127.0.0.1 11212
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
get city
VALUE city 0 7
tianjin
END
get city2
VALUE city2 0 7
beijing
END
delete city2
&lt;26 delete city2
REP&gt;26 DELETED
DELETED
</code></pre>

<blockquote><p>再次进入master，获取set的两个值，删除的数据是否可以get</p></blockquote>

<pre><code>[root@localhost ~]# telnet 127.0.0.1 11211
Trying 127.0.0.1...
&lt;31 new auto-negotiating client connection
Connected to 127.0.0.1.
Escape character is '^]'.
get city
31: Client using the ascii protocol
&lt;31 get city
&gt;31 sending key city
&gt;31 END
VALUE city 0 7
tianjin
END
get city2
&lt;31 get city2
&gt;31 END
END
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SQL COOKBOOK阅读笔记]]></title>
    <link href="http://nkcoder.github.io/blog/20140119/sql-cookbook-reading-note/"/>
    <updated>2014-01-19T19:38:59+08:00</updated>
    <id>http://nkcoder.github.io/blog/20140119/sql-cookbook-reading-note</id>
    <content type="html"><![CDATA[<h3>1. 尽量不要使用select *</h3>

<p>返回表中的所有field时，使用<code>select *</code>确实很方便，但是不推荐这么做，应该在select后将所有的field都列出来：一是方便自己，清楚地知道返回了哪些field；而是方便他人，在看你的代码时，别人不一定知道表中有哪些列。
这两种方式的性能是一样的。</p>

<h3>2. 尽量使用as创建易读的别名</h3>

<h4>2.1 尽量使用易读的别名</h4>

<pre><code>mysql&gt; select sal as salary, empName as employName from employ;
</code></pre>

<blockquote><p>使用易读的别名，可以让你的sql语句更容易被理解。</p></blockquote>

<h4>2.2 在where中使用别名：</h4>

<pre><code>mysql&gt; select sal as salary from employ where salary &gt;= 10000;
</code></pre>

<blockquote><p>该语句报错，因为salary字段未识别，可以将该语句包装成一个临时表：</p></blockquote>

<pre><code>mysql&gt; select * from (select sal as salary from employ) as t where salary &gt;= 10000;
</code></pre>

<blockquote><p>为什么：因为where语句在select之前执行，所以在第一条语句中，salary还没有创建；而from语句在where语句之前执行，所以在第二条语句中，临时表t中有字段salary。</p></blockquote>

<h3>3. 使用concat函数进行字段值的连接</h3>

<p>将字段值和字符串拼接起来，使用<code>concat()</code>函数：</p>

<pre><code>mysql&gt; select concat(startIp, " : ", endIp) as ipSeg from ip_data limit 1;
+---------------------+
| ipSeg               |
+---------------------+
| 17563648 : 17825791 | 
+---------------------+
</code></pre>

<h3>4. 使用case when进行条件判断</h3>

<p>在select语句中，可以对返回结果进行逻辑处理。使用case表达式，语法格式如下。else可以省略，如果所有的when
都不匹配，默认返回null；</p>

<pre><code>case
    when ... then
    when ... then
    else ...
end
</code></pre>

<blockquote><p>注意，还有一个case表达式，用于存储过程，以<code>end case</code>结尾。</p></blockquote>

<pre><code>mysql&gt; select netId, areaId, case when netId &gt; 10 then 'big' when netId &lt; 5 then 'small' else 'normal' end as status from ip_data limit 5;
+-------+--------+--------+
| netId | areaId | status |
+-------+--------+--------+
|    11 |   4019 | big    | 
|     2 |   2813 | small  | 
|    10 |     35 | normal | 
|     1 |   2110 | small  | 
|    10 |     35 | normal | 
+-------+--------+--------+
</code></pre>

<h3>5. 使用rand返回随机的记录</h3>

<p>可以使用<code>rand()</code>函数返回一个随机数，通过order by排序即可。rand()对每一条记录返回0.0到1.0之间的浮点数。
当然也可以在order by之后跟一个常量浮点数，但此时结果是固定的。</p>

<pre><code>mysql&gt; select ip_data.netId, ip_data.areaId from ip_data order by rand() limit 5;
+-------+--------+
| netId | areaId |
+-------+--------+
|     7 |   4019 | 
|    10 |   1806 | 
|     2 |   4608 | 
|    13 |     42 | 
|     3 |   4502 | 
+-------+--------+
</code></pre>

<h3>6. 使用is null判断字段是否为null</h3>

<p>判断字段null值，不能使用=或者!=，即使null和null也不能通过=比较。应该使用 <code>is null</code>, 或者 <code>is not null</code>。</p>

<pre><code>mysql&gt; select startIp, areaId from ip_data where netId  is null;
</code></pre>

<h3>7. 使用coalesce函数对字段进行默认处理</h3>

<p>对字段的返回值进行合并，使用函数<code>coalesce(field, default)</code>：如果field不为null，取field的值，如果field值为null，取设置的默认值default。</p>

<pre><code>mysql&gt; select number, coalesce(number, 1000) as new_number  from students;
+--------+------------+
| number | new_number |
+--------+------------+
|    111 |        111 | 
|   NULL |       1000 | 
|    333 |        333 | 
|  12345 |      12345 | 
|   NULL |       1000 | 
|    777 |        777 | 
|   NULL |       1000 | 
+--------+------------+
</code></pre>

<blockquote><p>当然，在select里使用<code>case when end</code>也能达到同样的效果，但显然使用coalesce()更简洁。</p></blockquote>

<h3>8. 在order by之后通过数字指定字段进行排序</h3>

<p>order by一般后跟字段名，表示根据字段名排序；也可以跟一个整数，该整数的值与select中的字段相对应，从1开始，表示根据select中的第几个字段排序，因此，该整数不能大于select中的字段个数。如下两种情况是等价的：</p>

<pre><code>mysql&gt; select id, startIp, endIp, netId from ip_data order by id asc limit 5; 
mysql&gt; select id, startIp, endIp, netId from ip_data order by 1 asc limit 5;
+----+----------+----------+-------+
| id | startIp  | endIp    | netId |
+----+----------+----------+-------+
|  1 | 17563648 | 17825791 |    11 | 
|  2 | 18350080 | 18874367 |     2 | 
|  3 | 19726336 | 19791871 |    10 | 
|  4 | 19922944 | 20054015 |     1 | 
|  5 | 20054016 | 20119551 |    10 | 
+----+----------+----------+-------+
</code></pre>

<p>另外，可以根据多个字段排序，优先级从左到右，即先根据第一个字段排序，如果第一个字段的值相等，然后根据第二个字段的值排序，依此类推：</p>

<pre><code>&gt;&gt; select id, startIp, endIp, netId from ip_data order by netId asc, endIp desc limit 5;
+-------+------------+------------+-------+
| id    | startIp    | endIp      | netId |
+-------+------------+------------+-------+
| 17351 | 3757047808 | 3757572095 |     1 | 
| 17348 | 3755737088 | 3755868159 |     1 | 
| 17347 | 3755343872 | 3755474943 |     1 | 
| 17341 | 3754295296 | 3754426367 |     1 | 
| 17337 | 3750756352 | 3751804927 |     1 | 
+-------+------------+------------+-------+
</code></pre>

<h3>9. 通过substring函数对字段子串排序</h3>

<p>使用函数<code>substring()</code>可以获取字符串的子串，使用<code>order by</code>可以根据该子串进行排序。
注意：substring(str, pos)表示从pos开始的子串，其中位移从1开始，所以如果要表示
取字符串的最后两个字符，应该是substring(str, length(str)-1).</p>

<pre><code>mysql&gt; select file_path, file_name from file order by substr(file_name, length(file_name)-1) desc  limit 5;
+----------------+-----------------------+
| file_path      | file_name             |
+----------------+-----------------------+
| /opt/rankFile/ | phb_variety_day_issue | 
| /opt/rankFile/ | catalog_variety       | 
| /opt/rankFile/ | catalog_tv            | 
| /opt/rankFile/ | catalog_cartoon       | 
| /opt/rankFile/ | catalog_doc           | 
+----------------+-----------------------+
</code></pre>

<h3>10. 如何对含有null值的字段进行排序</h3>

<p>mysql中字段的null值在排序时默认时按照最小值排序的，即升序时，null值在最前面，降序时在最后面。通过在select中使用<code>case when</code>对null值进行判断，然后定义排序顺序。
如升序时将null值放在最后：</p>

<pre><code>mysql&gt; select name, number from (select name, number, case when number is null then 0 else 1 end as is_null from students) as t order by is_null desc, number;
+----------+--------+
| name     | number |
+----------+--------+
| lingguo  |    111 | 
| lisi     |    333 | 
| guanyu   |    777 | 
| wangwu   |  12345 | 
| zhangsan |   NULL | 
| zhangfei |   NULL | 
| lingguo  |   NULL | 
+----------+--------+
</code></pre>

<h3>11. 字段值不同，排序的字段不同，如何实现？</h3>

<p><code>case when</code>语句也可以在<code>order by</code>中，不同的条件，使用不同的字段进行排序。
比如：如果number字段的值不为null，根据number排序，否则，根据enable排序：</p>

<pre><code>mysql&gt; select name, number, enable from students order by case when number is null then enable else number end;
+----------+--------+--------+
| name     | number | enable |
+----------+--------+--------+
| zhangsan |   NULL |      0 | 
| zhangfei |   NULL |      0 | 
| lingguo  |   NULL |      1 | 
| lingguo  |    111 |      1 | 
| lisi     |    333 |      1 | 
| guanyu   |    777 |      0 | 
| wangwu   |  12345 |      0 | 
+----------+--------+--------+
</code></pre>

<h4>参考：</h4>

<ul>
<li><a href="http://book.douban.com/subject/1840666/">SQL Cookbook</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2014-01-11 日记]]></title>
    <link href="http://nkcoder.github.io/blog/20140111/diary/"/>
    <updated>2014-01-11T23:13:35+08:00</updated>
    <id>http://nkcoder.github.io/blog/20140111/diary</id>
    <content type="html"><![CDATA[<p>今天是个周六，按照我们码农的习惯，至少得中午起吧，洗洗直接吃个午饭。可我就没这么好的命啦，每天早上8点前得给我的部门老大发系统值班的报告（为什么呢？简而言之，就是这个系统在我接手之前，出过几次故障，本来也不是什么大事，关键是这几次故障都是被公司的张老大第一个亲自发现的，那问题就严重了，直接导致我现在的部门老大那是谨小慎微啊，我也是如履薄冰啊，幸好到现在为止，还没出过什么事），周末也不例外。不过由此带来的一个“副作用”就是，我每天7点左右起，完成值班报告，总不能回去继续睡个回笼觉吧，正好可以用来看看书，或者读读英语，现在都养成习惯了，算是额外的一个收获吧。</p>

<p>早上也没什么异常报警，照例看看系统的各个页面以及日志是否正常。当看到频道页的一个榜单时，感觉不对劲，我立马知道问题处在哪儿了。这是前两天产品提的一个需求，需要前端和后台配合，我开发完了，将文件推送到cms的测试目录，将测试地址给了产品经理；然后，前端找产品经理要文件地址，产品经理把测试地址给了前端，后来前端说，她是找产品要的地址，调试完了直接上线了（引用的测试地址，因为线上的文件是当天生成的，而测试地址的是旧文件），关键是她上线时候，至少应该通知我或者产品一声的，而且我给的地址里明显含有test关键字，于是我就很郁闷。大周末的，谁都找不着，产品说周一再说吧。但排行榜是我的系统，出问题，我是首当其冲。跟我主管知会了一下，他也很郁闷，没办法，我只能默默地将系统上线，更新文件，然后推送到测试地址，以保证系统的展示是正常的。开发、产品和前端如果沟通不好，真的很容易出问题，有了这次的教训，以后不能单线和前端或者产品沟通，必须大家都在，把问题说清楚。</p>

<p>中午找个地方吃完饭，去公司加班了，还有点活。到公司一看，发现Xi Chen也在，每一会儿，主管也来了，好么，今天是组内加班聚会么。下午快要下班的时候，主管要上线个系统，让我帮忙做个code review（此时Xi Chen提前撤了），当然ok。其实所谓code review，就是听开发者在代码级讲解一遍系统的逻辑、功能和实现，主要是check一下逻辑是否严密，是否有没有考虑到的问题，或者由于粗心将代码写串了等编码问题。我觉得code review 还是很有必要的，开发者在开发的过程中，或者由于系统功能较复杂，或者由于编码周期比较长，代码量较大，容易遗漏问题。通过将思路和逻辑讲给同事听（也许他不一定对系统多么熟悉），相当于捋一遍思路，有的时候自己就能发现，噢，原来这个地方还有个问题没有考虑到呢；另一方面，同事也可以根据自己的理解和经验提出疑问，通过解答疑问，使得逻辑更加严密。</p>

<p>其实今天做code review的时候，就有一个小问题被我发现了：通过PreparedStatement的executeBatch()方法，批处理向数据库插入数据，示例代码如下：</p>

<div class="highlight"><pre><code class="java"> <span class="n">Connection</span> <span class="n">conn</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="n">PreparedStatement</span> <span class="n">statement</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="n">database</span><span class="o">.</span><span class="na">getConnection</span><span class="o">();</span>
        <span class="n">statement</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="na">prepareStatment</span><span class="o">(</span><span class="n">SQL_INSERT</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">VideoInfo</span> <span class="nl">info:</span> <span class="n">videoInfoList</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">statement</span><span class="o">.</span><span class="na">setInt</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">info</span><span class="o">.</span><span class="na">getVid</span><span class="o">());</span>
            <span class="n">statement</span><span class="o">.</span><span class="na">setString</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">info</span><span class="o">.</span><span class="na">getTvName</span><span class="o">());</span>
            <span class="c1">// ...</span>

            <span class="k">if</span> <span class="o">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="mi">50</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">statement</span><span class="o">.</span><span class="na">executeBatch</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">statemetn</span><span class="o">.</span><span class="na">executeBatch</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="c1">// ...) {</span>
        <span class="c1">// ...</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="c1">// ...</span>
    <span class="o">}</span>
    
</code></pre></div>


<p>讲解到这段代码时，我试探性地问，有没有加入批处理的操作，主管一看，哦，对，写漏了一句：statement.addBatch();赶紧补上，我们相视一笑。其实，我还从来没在代码里是用过mysql的批处理api，我之所以会有疑问，是因为我在学习<a href="http://www.elasticsearch.org/">ElasticSearch</a>的时候，使用过其批量导数据的接口，和上述代码如出一辙，这也让我感叹，很多知识都是相通的，在一些好的方面，也是相互借鉴的。这也让我坚信，知识的广度是多么地重要。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySql优化一则]]></title>
    <link href="http://nkcoder.github.io/blog/20140107/mysql-optimize-in-project/"/>
    <updated>2014-01-07T21:38:18+08:00</updated>
    <id>http://nkcoder.github.io/blog/20140107/mysql-optimize-in-project</id>
    <content type="html"><![CDATA[<h3>1. 提出问题</h3>

<p>根据视频的播放数实现排行榜。需要关联4张表：专辑表、视频表、专辑和视频的关联表以及视频的播放数日增表，日增表的日数据大概在2万条左右。出排行榜的sql如下：</p>

<pre><code>SELECT
    vts.TV_ALUMN_ID AS albumId, inc.tv_vid, inc.tv_id, vts.TV_NAME AS tvName,
    sum( inc.tv_count + inc.tv_count_app) AS realCount, sum( inc.tv_display_count + inc.tv_display_count_app) AS showCount
FROM
    vrs2_playlist vp, vrs2_tv_playlist vtp, vrs_tv_set vts, t_vrs_video_day_inc inc
WHERE
    vp.ID = vtp.TV_PLAYLIST_ID AND vtp.TV_ID = inc.tv_id AND vts.ID = vtp.TV_ID 
AND vts.TV_ALUMN_ID = vp.id AND inc.tv_date BETWEEN ?  AND ? AND vp.IS_BD != 0 
AND vp.TV_IS_INTREST != 1 AND vp.TV_EFFECTIVE = 1 AND vp.TV_IS_TEST = 0 AND vts.IS_BD != 0
AND ( vts.TV_S_TYPE &lt; 2 OR vts.TV_S_TYPE IS NULL)
AND vp.TV_CATEGORY_ID = ?  GROUP BY inc.tv_vid ORDER BY showCount DESC LIMIT 100
</code></pre>

<blockquote><p>如果是日榜，查询时间大约在8s左右，还可以接受。如果是周榜，大概需要1min，如果是月榜，耗时约2~3分钟。周榜和月榜的时间是令人难以接受的。</p></blockquote>

<h3>2. 优化方案</h3>

<p>我采取的方案是：在日增数据的基础上，进行一周和一月的数据的汇总，生成周增表和月增表，周榜和月榜直接从周增表和月增表里查询。</p>

<h4>2.1 通过insert into select汇总数据</h4>

<p>创建表结构之后（周增表和月增表的表结构和日增表一致），通过insert into TABLE select 语句可以将查询的结果写入指定的表中，完整的SQL语句为：</p>

<pre><code>INSERT INTO t_vrs_video_week_inc (tv_id,tv_vid,tv_count,tv_display_count,tv_count_app,tv_display_count_app,tv_date) SELECT 
tv_id, tv_vid, sum(tv_count) as tv_count, sum(tv_display_count) as tv_display_count, sum(tv_count_app) as tv_count_app, 
sum(tv_display_count_app) as tv_display_count_app, SUBDATE(CURDATE(),INTERVAL WEEKDAY(CURDATE())+7 DAY) AS tv_date 
FROM t_vrs_video_day_inc inc WHERE inc.tv_date BETWEEN SUBDATE(CURDATE(),INTERVAL WEEKDAY(CURDATE())+7 DAY) AND 
SUBDATE(CURDATE(),INTERVAL WEEKDAY(CURDATE())+1 DAY) GROUP BY inc.tv_vid
</code></pre>

<p>但是，如果数据量稍大，这个操作会失败，MySql提示binlog太小了。binlog用来记录数据库发生变化的“事件&#8221;，如创建表或修改表中的数据，我们的INSERT INTO语句就会使用binlog，但是select语句和show语句因为仅仅是查询，不会使用binlog。所以得想别的办法。</p>

<h4>2.2 通过load data从文件导数据</h4>

<p>因为select语句不会受binlog的限制，也就是说，数据是可以查出来的，只是没法一下子写入表中。我们可以先将查出来的数据写入文件，然后通过MySql的load data local infile命令从文件中将数据导入表中。
查询数据存入文件：</p>

<pre><code>selectSql="SELECT tv_id, tv_vid, sum(tv_count) as tv_count, sum(tv_display_count) as tv_display_count, sum(tv_count_app) 
as tv_count_app, sum(tv_display_count_app) as tv_display_count_app, SUBDATE(CURDATE(),INTERVAL WEEKDAY(CURDATE())+7 DAY) 
AS tv_date FROM t_vrs_video_day_inc inc WHERE inc.tv_date BETWEEN SUBDATE(CURDATE(),INTERVAL WEEKDAY(CURDATE())+7 DAY) 
AND SUBDATE(CURDATE(),INTERVAL WEEKDAY(CURDATE())+1 DAY) GROUP BY inc.tv_vid"

mysql -h10.11.12.13 -uuser -ppasswd -Dvideo -s --skip-column-names -e "$selectSql" &gt; $dataFilePath
</code></pre>

<p>从文件将数据load进表中：</p>

<pre><code>loadDataSql="load data local infile '$dataFilePath' into table t_vrs_video_week_inc (tv_id,tv_vid,tv_count,tv_display_count,
tv_count_app,tv_display_count_app,tv_date)"

mysql -h10.11.12.13 -uuser -ppasswd -Dvideo -s --skip-column-names -e "$loadDataSql"
</code></pre>

<h3>3. 总结</h3>

<p>优化之后，周榜和月榜的耗时大概在10s左右，与日榜差不多。整个系统的执行时间从30min左右降到10分钟左右，应该说效果还是比较明显的。
我的方案只是一种形式的优化，肯定不是最优的，比如多表联查的效率很低，这应该也是个优化点，还会继续探索。</p>

<h4>参考</h4>

<ul>
<li><a href="http://dev.mysql.com/doc/refman/5.7/en/binary-log.html">5.2.4. The Binary Log</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用github pages和Octopress搭建静态博客及配置]]></title>
    <link href="http://nkcoder.github.io/blog/20140105/github-pages-and-octopress-blog-built/"/>
    <updated>2014-01-05T22:07:11+08:00</updated>
    <id>http://nkcoder.github.io/blog/20140105/github-pages-and-octopress-blog-built</id>
    <content type="html"><![CDATA[<blockquote><p>初衷：其实，前不久才购买的域名和主机，使用wordpress搭建的博客，但是wordpress功能完善地有些笨拙，再加上购买的主机速度慢地难以忍受，连写博客的欲望都没有了。后来发现github pages和Octopress可以组合搭建静态博客，托管在github上，既稳定又方便，我只要关注博客就行了。所以这两天都在折腾。</p></blockquote>

<h3>1. 环境准备</h3>

<h4>1.1 下载软件：<code>RubyInstaller</code>，<code>Devkit</code>，<code>git</code></h4>

<p>先在下载地址<a href="http://rubyinstaller.org/downloads/">rubyinstaller</a>看说明，当前建议下载1.9.3稳定版<code>RubyInstaller</code>：<code>Ruby 1.9.3-p484</code>和<code>DevKit-tdm-32-4.5.2-20111229-1559-sfx.exe</code>。（我因为下载的时2.0版，后来配置的时候报错了，版本改为1.9.3就ok了）
git可以下载最新版的<a href="https://code.google.com/p/msysgit/downloads/list">msysgit</a>即可。</p>

<h4>1.2 安装ruby</h4>

<p>安装RubyInstaller，注意不要安装在带有空格的目录中，如C:\Program Files，否则后面有些命令可能会出错；安装时选择将可执行路径加入到PATH环境变量中。Devkit解压即可，然后进入devkit目录，执行安装命令：</p>

<pre><code>$ cd Devkit
$ ruby dk.rb init
$ ruby dk.rb install    
</code></pre>

<h4>1.3 安装python和pygments</h4>

<p>python2.7: <a href="http://www.python.org/ftp/python/2.7.6/python-2.7.6.msi">http://www.python.org/ftp/python/2.7.6/python-2.7.6.msi</a></p>

<p>pygments的安装：
先下载ez_setup.py脚本：<a href="https://pypi.python.org/pypi/setuptools#windows%EF%BC%8C%E7%84%B6%E5%90%8E%E6%89%A7%E8%A1%8C%EF%BC%9A">https://pypi.python.org/pypi/setuptools#windows%EF%BC%8C%E7%84%B6%E5%90%8E%E6%89%A7%E8%A1%8C%EF%BC%9A</a></p>

<pre><code>$ python ez_setup.py
</code></pre>

<p>会下载setuptools-2.2.tar.gz，解压并进入：</p>

<pre><code>$ cd dist\setuptools-2.2
$ python easy_install.py pygments
</code></pre>

<h4>1.4 安装Octopress</h4>

<p>默认是官方的源，在国内比较慢，建议换成国内淘宝的ruby源：</p>

<pre><code>$ gem sources -a http://ruby.taobao.org
$ gem sources -r http://rubygems.org
$ gem sources -l
</code></pre>

<p>安装Octopress到指定的目录：</p>

<pre><code>git clone git://github.com/imathis/octopress.git /d/yousharp
</code></pre>

<p>打开安装目录/d/yousharp的Gemfile文件，将第一行的source改为淘宝的源：</p>

<pre><code>source "http://ruby.taobao.org"
</code></pre>

<h4>1.5 安装bundler</h4>

<pre><code>$ gem install bundler
$ bundle install
</code></pre>

<h4>1.5 安装主题，生成博客并预览</h4>

<p>Octopress的<a href="http://opthemes.com/">主题列表</a>，我使用的是：<a href="https://github.com/bkutil/bootstrap-theme">Bootstrap theme</a>：</p>

<pre><code>$ git clone git://github.com/bkutil/bootstrap-theme.git bootstrap-theme
$ cp -R bootstrap-theme $MY_OCTOBLOG/.themes/bootstrap
$ rake install['bootstrap']
$ rake generate
$ rake preview
</code></pre>

<blockquote><p>访问<a href="http://localhost:4000">http://localhost:4000</a>即可预览。</p></blockquote>

<h4>1.6 修改环境变量支持中文</h4>

<p>新建环境变量：LANG 和 LC_ALL，值均为zh_CN.UTF_8</p>

<h3>2. 托管到github pages</h3>

<h4>2.1 新建github repo</h4>

<p>在<a href="http://github.com">github</a>新建一个repo，命名为USERNAME.github.io，使用你github的用户名取代USERNAME，如：nkcoder.github.io。</p>

<h4>2.2 github配置</h4>

<pre><code>$ git config --global user.name "nkcoder"
$ git config --global user.email "daniel5hbs@gmail.com"
$ git config --global credential.helper cache
$ git config --global credential.helper 'cache --timeout=3600'
</code></pre>

<blockquote><p>注意：credential helper 只对https有效，对ssh无效。</p></blockquote>

<p>生成rsa key，并添加到github的SSH keys中：</p>

<pre><code>$ ssh-keygen -t rsa -C "daniel5hbs"
$ ssh -T git@github.com
</code></pre>

<h4>2.3 博客发布</h4>

<pre><code>$ rake setup_github_pages
$ rake generate
$ rake deploy
访问nkcoder.github.io。
</code></pre>

<h3>3. 新建博客或页面</h3>

<pre><code>$ rake new_post['first-blog']
$ rake new_page['about']
$ rake generate
$ rake preview 
</code></pre>

<blockquote><p>说明：使用<code>$ rake preview</code>可以监视文件的变动，可以实时预览修改，但是如果修改了_config.yml或者该配置文件引用的文件发生了变化，则需要重新<code>$ rake generate</code>。</p></blockquote>

<h3>4. 主题优化</h3>

<h4>4.1 添加disqus评论</h4>

<p>先去<a href="http://disqus.com/">disqus</a>注册一个帐号，然后修改根目录/d/yousharp下的_config.yml文件，修改为：</p>

<pre><code># Disqus Comments
disqus_short_name: nkcoder
disqus_show_comment_count: yes 
</code></pre>

<blockquote><p>注意：将nkcoder替换为你的disqus帐号。</p></blockquote>

<h4>4.2 代码高亮</h4>

<p>首先下载安装python 2.x版本，然后修改_config.yml，修改为：</p>

<pre><code>pygments: true
</code></pre>

<blockquote><p>注意冒号后有个空格。</p></blockquote>

<p>在需要高亮的代码块使用语法：</p>

<div class="highlight"><pre><code class="java"> <span class="n">your</span> <span class="n">code</span>
    
</code></pre></div>


<p>或者使用三个反引号（左Alt键右边的键)：</p>

<pre><code>```java
your code
```
</code></pre>

<h4>4.3. 在页面右侧添加分类等模块</h4>

<p>系统自带的模块放在了目录：source/<em>include/asides下，我们自定义的模块放在目录：source/</em>include/custom/asides下。
模块一：分类及标签
使用插件<a href="https://github.com/ctdk/octopress-category-list">octopress-category-list</a>
下载下来后，将category_list.rb放在plugins目录下，将category_list.html和category_cloud.html放在source/_include/custom/asides目录下；</p>

<p>模块二：最新博文
这是系统默认的模块，在source/_include/asides目录下的recent_posts.html，样式可以自己修改；</p>

<p>模块三：博客链接
在source/_include/custom/asides目录下新建blogroll.html，比如内容可以为：</p>

<pre><code>&lt;section&gt;
    &lt;h4&gt; Blogroll &lt;/h4&gt;
    &lt;ul&gt;
        &lt;li&gt;&lt;a href="http://ifeve.com/" target="_blank"&gt;并发编程网&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href="http://tengine.taobao.org/book/index.html#" target="_blank"&gt;Nginx开发从入门到精通&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href="http://timyang.net/" target="_blank"&gt;Tim Yang&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
&lt;/section&gt;
</code></pre>

<p>模块四：豆瓣阅读列表
新建douban.html，进入<a href="http://www.douban.com/service/badgemakerjs">豆瓣收藏秀</a>生成js代码，将内容写入douban.html中，如：</p>

<pre><code>&lt;section&gt;
    &lt;h4&gt; Want To Read&lt;/h4&gt;
    &lt;div&gt;
    &lt;script type="text/javascript" src="http://www.douban.com/service/badge/daniel5hbs/?selection=random&amp;amp;picsize=small&amp;amp;hideself=on&amp;amp;show=wishlist&amp;amp;n=9&amp;amp;cat=book&amp;amp;columns=3"&gt;&lt;/script&gt;
    &lt;/div&gt;
&lt;/section&gt;
</code></pre>

<p>模块五：disqus最新评论
新建模块文件：recent_comments.html，写入disqus的js代码，如：</p>

<pre><code>&lt;section&gt;
    &lt;h4&gt; Recent Comments &lt;/h4&gt;
    &lt;div id="dsq-recentcomments" class="dsq-widget"&gt;&lt;script type="text/javascript" src="http://disqus.com/forums/nkcoder/recent_comments_widget.js?hide_avatars=0"&gt;&lt;/script&gt;&lt;/div&gt;
&lt;/section&gt;
</code></pre>

<p>然后修改_config.yml文件，将需要在侧边显示的模块包含在default_asides里，如：</p>

<pre><code>default_asides: [custom/asides/category_list.html, asides/recent_posts.html, custom/asides/blogroll.html, custom/asides/douban.html, custom/asides/recent-comment.html]
</code></pre>

<blockquote><p>根据包含的顺序，自上向下地展示。</p></blockquote>

<h4>4.4 显示摘要</h4>

<p>在文章中的某一行添加如下代码即可：</p>

<pre><code>&lt;!--more--&gt;
</code></pre>

<p>页面显示“Read on->&ldquo;， 剩下的内容会隐藏。</p>

<h3>5. 不同环境下博客的同步</h3>

<p>如果电脑中的文件丢失了，或者换电脑了，或者需要在另一个环境下写博客，则需要将博客拷贝到本地，并配置环境。</p>

<h4>5.1 分支的概念</h4>

<p>Octopress默认有两个分支，一个是source，包含生成博客的所有文件，另一个是master，即博客本身。
当我们本地配置完后，master分支在目录_deploy中，因为以下划线开头，当我们向source分支提交时$ git push -u origin source时，master分支被忽略，而当我们使用rake部署时$ rake deploy，master分支则更新。</p>

<h4>5.2 将博客拷贝到本地的步骤</h4>

<p>如果当前没有python和ruby的环境，则需要执行本博客1.1到1.3中的步骤，配置环境；</p>

<p>首先将source分支拷贝到本地的博客目录：</p>

<pre><code>$ git clone -b source git@github.com:nkcoder/nkcoder.github.io.git yousharp
</code></pre>

<blockquote><p>将其中的nkcoder替换为你自己的用户名，将yousharp替换为你的博客目录。</p></blockquote>

<p>然后，将master分支拷贝到_deploy目录：</p>

<pre><code>$ cd mybolg
$ git clone git@github.com:nkcoder/nkcoder.github.io.git _deploy
</code></pre>

<p>最后，安装与配置：(注意：将source修改为国内淘宝的)</p>

<pre><code>$ gem install bundler
$ bundle install
$ rake setup_github_pages
</code></pre>

<p>可能需要输入github repo的地址，</p>

<pre><code>Enter the read/write url for your repository
(For example, 'git@github.com:nkcoder/nkcoder.github.io.git)
</code></pre>

<h4>5.3 不同环境的同步</h4>

<p>在切换环境之前，确保对所做的修改都提交了：</p>

<pre><code>$ ranke generate
$ git add .
$ git commit -am 'your comment'
$ git push origin source
$ rake deploy 

切换环境之后，将所有的更新拷贝下来：

$ cd myblog
$ git pull origin source
$ cd ./_deploy
$ git pull origin master
</code></pre>

<h4>参考博文：（非常感谢）</h4>

<ul>
<li><a href="http://blog.zerosharp.com/clone-your-octopress-to-blog-from-two-places/">Clone Your Octopress to Blog From Two Places</a></li>
<li><a href="http://arshad.github.io/blog/2012/05/04/recent-comments-in-octopress/">Recent Comments in Octopress</a></li>
<li><a href="http://corey600.github.io/blog/2013/02/28/use-github-and-octopress-create-blog/">用Github和Octopress搭建博客</a></li>
<li><a href="http://www.yanjiuyanjiu.com/blog/20130401/">使用github + Octopress 搭建免费博客</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[vim 常用的基本操作]]></title>
    <link href="http://nkcoder.github.io/blog/20140105/vim-basic-usage/"/>
    <updated>2014-01-05T14:52:26+08:00</updated>
    <id>http://nkcoder.github.io/blog/20140105/vim-basic-usage</id>
    <content type="html"><![CDATA[<h3>1. vim的三种模式</h3>

<ul>
<li><p>vim有三种模式，不同的模式对应着不同的操作，完成不同的功能；这三种模式分别是：一般模式，编辑模式和命令模式。</p></li>
<li><p>一般模式：当我们使用vim打开文件时，就处于一般模式，一般模式是三种模式中的桥梁，也就是说可以从一般模式切换到命<br/>
令模式或者编辑模式，但命令模式和编辑模式之间的切换必须经过一般模式，即先切换到一般模式，然后再进入另一种模式，编<br/>
辑模式和命令模式之间是无法直接切换的。如何从另两种模式进入一般模式呢？按ESC即可。</p></li>
<li><p>编辑模式：可以对文件的内容进行编辑操作，比如增加、删除和修改，就像使用notepad编辑文件一样；从一般模式进入编辑<br/>
模式的命令主要有：i, I, a, A, o, O, s, S;（后面会详解）。</p></li>
<li><p>命令模式：该模式下主要是用于文件的保存退出，从一般模式进入命令模式的方法是：冒号(:)。</p></li>
</ul>


<h3>2. 一般模式下的常用操作：</h3>

<h4>2.1 光标移动</h4>

<pre><code>h, j, k, l: 向左、下、上、右移动一个字符；前面加上数字n，表示移动n个字符，如3j表示向下移动三个字符，即三行；

b, B: 表示begin，从字符所在的单词开始，b表示移动到前一个短单词的第一个字符处；B表示移动到前一个长单词的第一个字符处，两个空白之间的单词为一个长单词，比如hello how're you, how,'和re分别为三个短单词，但只是一个长单词；
e, E: 与b, B类似，从字符所在的单词开始，分别向后移动一个短单词、长单词；

(, ): 从光标所在的语句块开始，(表示移动到前一个语句块，)表示移动到后一个语句块；
{, }: 从光标所在的段落开始，{表示向前移动一个段落，}表示向后移动一个段落；可以理解为从一个空行移动到前一个或者后一个空行；
%: 跳转到匹配的(, ), {, }, [, ]

CTRL+f: 屏幕向下翻页，相当于PgUp;
CTRL+b: 屏幕向上翻页，相当于PgDn；


0: 移动到光标所在行的第一个字符处；
$: 移动到光标所在行的最后一个字符处；
^: 移动到光标所在行的第一个非空字符处；

gg: 移动到文件的第一行（且是第一个字符处）；
G: 移动到文件的最后一行（且是第一个字符处）；
数字n+G: 表示移动到第n行，如5G，表示移动到文件的第5行；
说明：以上这些命令非常常用，熟记的同时要熟练；

数字n+空格space: 表示向右移动n个字符，即n+space，等价于nl；
数字n+回车Enter: 表示向下移动n行，等价于nj；
</code></pre>

<h4>2.2 查找替换</h4>

<pre><code>/word: 从光标所在处向下搜索关键字word；
?word: 从光标所在处向上搜索关键字word；
n: 向下搜索，查找下一个匹配项；
N: 向上搜索，查找上一个匹配项；
*：对光标所在的单词，向下查找；
#: 对光标所在的单词，向上查找；
说明：一般情况下，/word和n、N配合完成查找，而?word用得较少；

:n1,n2s/src/dest/g: 在n1行到n2行之间（包括n1行和n2行），查找src，并将所有的src替换成dest；
:1,$s/src/dest/g: 查查找范围为第一行到最后一行，将所有的src替换为dest，只是在替换时会有确认；
:.,$s/src/dest/g: 查找范围为当前行到最后一行，将所有的src替换为dest；(因为在命令模式下，.表示当前行)
</code></pre>

<h4>2.3 删除、复制与粘贴</h4>

<pre><code>x, X: x表示删除光标后的一个字符，X表示删除光标前的一个字符，前面可以加上数字n，表示删除n个字符， 即nx, nX；
dd: 表示删除光标所在的行，前面带上数字n，表示删除当前行往下的n行（包括当前行）；
d$: 表示删除光标所在的位置到该行的最后一个字符；
d0: 表示删除光标所在的位置到该行的第一个字符处；
d^: 表示删除光标所在的位置到该行的第一个非空字符处；
D: 删除光标所在字符到该行最后一个字符，等价于d$；
dt+字符c: dt后接一个字符c，表示从光标所在字符开始，删除该行的字符知道遇到第一个为c的字符为止，如果在该行，光标所在字符后不存在字符c，则什么也不做；
dG: 表示删除当前行到最后一行；
dgg: 表示删除当前行与第一行；
dnG: 表示删除当前行与第n行；

yy: 复制光标所在那一行的内容；
yG: 复制光标所在行与最后一行之间的内容；
ygg: 复制光标所在行与第一行之间的内容；
ynG: 复制光标所在行与第n行之间的内容；
y$: 复制光标所在的字符到该行的最后一个字符；
y0: 复制光标所在的字符到该行的第一个字符；
y^: 复制光标所在的字符到该行的第一个非空字符；
p, P: p表示将复制的数据粘贴在光标所在行的下一行；P表示将复制的数据粘贴在光标所在行的上一行；
说明：如果复制的内容是以行为单位，则p和P就粘贴在当前行的下一行或上一行，如果复制的内容是以字符为单位，即针对y$, y0或者y^，p和P会粘贴在光标的后面。

u: 复原上一个操作，类似于word中的还原；
CTRL+r: 重做上一个操作；
.: 重复前一个动作；相当于重新执行一遍前一个操作，比如前一个操作时dd，则.命令会再执行一遍dd；
r,R: r表示替换光标所在字符，R表示替换光标所在字符及其后的字符，直到按ESC为止；
</code></pre>

<h4>2.4 块选择</h4>

<pre><code>v: 字符选择，从光标所在字符开始，配合h, j, k, l进行字符的选择；
V: 行选择，将光标经过的行选中；
CTRL+v: 块选择，从光标所在字符开始，选中块；
y: 复制选中的内容；
p: 粘贴选中的内容；
</code></pre>

<h3>3. 编辑模式下的常用操作</h3>

<pre><code>在编辑模式下，就是对文件的内容进行增删改，没有特殊的操作，光标的移动还是得进入到一般模式；
从一般模式进入编辑模式的命令有：
i, I: i表示在光标所在字符之前插入，I表示在光标所在行的第一个非空字符前插入；
a, A: a表示在光标所在字符之后插入，A表示在光标所在行的最后一个非空字符后插入；

o, O: o表示在光标所在行的下一行插入，O表示在光标所在行的上一行插入；
s, S: s表示删除光标所在字符并进入插入模式，S表示删除光标所在行并进入插入模式；
说明：s和S使用地稍微较少一些；

CTR+n或者CTRL+p: 在编辑模式下，输入一些文字后，按CTRL+n或者CTRL+p可以出现提示文字；
</code></pre>

<h3>4. 命令行模式下的常用操作</h3>

<h4>4.1 保存退出</h4>

<pre><code>:w  保存文件内容，但不退出；
:q  退出vim；如果文件内容没有被修改，则直接退出，如果文件内容修改了但没有保存，则会提示先保存后退出；
:q!  强制退出vim；如果修改过文件但是没有保存，则不保存且强制退出；
:e!  将文件恢复到最原始的状态，即上次保存的状态；
:wq  保存后退出；
:x  保存后退出；
说明：其实最常用的命令当属:w, :q, :x，如果是有意的修改，则应该随时注意保存，即:w，离开时尽量使用:q，如果是有意修改，应该已经保存了，如果作了无意修改，则会提示，比较安全，只有在修改完之后，确定保存并离开，可以使用:x，不过还是尽量少用；
</code></pre>

<h4>4.2 文件读写</h4>

<pre><code>:w filename 将文件的内容另存为另一个文件
:n1,n2 w filename 将文件的n1和n2行之间的内容另存为另一个文件；
:w&gt;&gt;filename  将文件内容追加到另一个文件中；
:r filename  将另一个文件的内容读入到光标所在的下一行；
:f  显示当前文件的文件名
</code></pre>

<h4>4.3 其它常用</h4>

<pre><code>:set nu  显示行号
:set nonu  隐藏行号
:set hlsearch  查找时高亮显示匹配项
:set nohlsearch  查找时不高亮显示匹配项
说明：以上命令一般写入vim的配置文件里，这样就不需要每次都调这些命令了。
</code></pre>

<h3>5. 多文件及分屏编辑</h3>

<pre><code>:r filename命令可以读入整个文件的内容，但如果指向复制或者重用另一个文件的部分内容，怎么办呢？可以使用多文件编辑或者分屏编辑；

多文件：vim后接多个文件名，则可以在一个vim里打开多个文件，可以进行文件间的编辑；
:n  显示下一个文件；
:N  显示上一个文件；
:f  显示当前文件的文件名；
:files  显示所有的文件名；
说明：这样，可以从一个文件里复制部分内容，然后切换到另一个文件，将文件内容粘贴，实现多文件的编辑；

分屏：在一个屏幕上同时显示多个文件的内容，可以对照着编辑，很方便；
分屏显示有两种方式：
[1] 先使用vim打开一个文件，然后在命令行模式下可输入的命令有：
:sp filename  读入另一个文件，两个文件分水平的上下两屏来显示；如果不跟文件名，则新屏里也显示当前文件的内容；
:vsp filename 或者 :vsplit filename  读入另一个文件，两个文件分垂直的左右两屏来显示；如果不跟文件名，则新屏里也显示当前文件的内容；
分屏之后的常用命令有：
CTRL+w,[h,j,k,l]: 如果是横屏，则CTRL+w,j表示光标移入下方的屏，CTRL+w,k表示光标移入上方的屏；CTRL+w,h表示光标移入左侧的屏，CTRL+w,l表示光标移入右侧的屏；
CTRL+w,w: 表示在两个屏之间来回切换；
说明：CTRL+w,h的按键方式为：同时按下CTRL和w，放开或不放开都行，然后按下h；
CTRL+w,=: 表示将两个屏幕的宽度调整为相等；
[2] vim启动的时候同时打开多个文件：
$ vim -On file01 file02  分垂直两屏显示两个文件；
$ vim -on file01 file02  分水平两屏显示两个文件；
</code></pre>

<blockquote><p>说明：以上这些命令都是基础且常用的，不要死记硬背，应该在vim下多练习，直到输入这些命令成为一种无意识的行为；vi
m的功能很强大，而且支持丰富的插件，比如ctags等，有兴趣的可以找相关的文章参考；</p></blockquote>
]]></content>
  </entry>
  
</feed>
